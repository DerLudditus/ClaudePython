<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title>How to reverse a number in Python</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@700&amp;family=Literata:wght@400;700&amp;family=Fira+Code:wght@400;700&amp;display=swap" rel="stylesheet" type="text/css" />
  <link href="styles.css" rel="stylesheet" type="text/css" />
</head><body id="top">
  <script src="script.js"></script>
<h1><a href="index.html">How to reverse a number in Python</a></h1><div><div><div><p>Reversing numbers in Python enables you to flip digits from left to right, transforming numbers like 12345 into 54321. This fundamental operation finds applications in algorithms, data processing, and mathematical computations.</p><p>This guide covers multiple techniques for number reversal, practical tips, and real-world use cases. All code examples were created with <a href="https://claude.ai/">Claude</a>, an AI assistant built by Anthropic.</p><h2>Basic number reversal with string conversion</h2><pre><code>num = 12345
reversed_num = int(str(num)[::-1])
print(f&quot;Original: {num}, Reversed: {reversed_num}&quot;)</code></pre><pre><code>Original: 12345, Reversed: 54321</code></pre><p>The string conversion method leverages Python's string slicing capabilities to reverse numbers efficiently. Converting the integer to a string allows us to use the <code>[::-1]</code> slice operator, which creates a reversed copy of the sequence. This approach offers a clean, readable solution that works well for most numerical reversal needs.</p><p>While this technique requires type conversion between <code>int</code> and <code>str</code>, it provides several advantages:</p><ul><li>Simple implementation with minimal code</li><li>Handles leading zeros naturally when converting back to integers</li><li>Works consistently across different Python versions</li><li>Maintains good performance for typical number sizes</li></ul><h2>String-based techniques</h2><p>Building on the string conversion approach, Python offers several elegant techniques to reverse numbers—from methodically breaking down the steps to using built-in functions like <code>reversed()</code> and list comprehensions.</p><h3>Breaking down string reversal steps</h3><pre><code>num = 7890
num_str = str(num)
reversed_str = num_str[::-1]
reversed_num = int(reversed_str)
print(reversed_num)</code></pre><pre><code>987</code></pre><p>This step-by-step approach breaks down number reversal into distinct operations for clarity and learning. The process starts by converting the integer <code>7890</code> to a string using <code>str()</code>. Python's slice operator <code>[::-1]</code> then creates a reversed copy of that string.</p><ul><li>The <code>str()</code> function transforms the number into a sequence of characters we can manipulate</li><li>The slice operator works from right to left, collecting each character in reverse order</li><li>Converting back to an integer with <code>int()</code> removes any leading zeros automatically</li></ul><p>This explicit method helps developers understand each transformation happening under the hood. It's particularly useful when debugging or when you need to modify specific steps in the reversal process.</p><h3>Using the <code>reversed()</code> function</h3><pre><code>num = 12345
reversed_str = &#x27;&#x27;.join(reversed(str(num)))
reversed_num = int(reversed_str)
print(reversed_num)</code></pre><pre><code>54321</code></pre><p>The <code>reversed()</code> function provides a memory-efficient way to reverse sequences in Python. When combined with <code>join()</code>, it creates a clean approach to number reversal that's both readable and performant.</p><ul><li>The <code>reversed()</code> function returns an iterator of characters in reverse order instead of creating a new string in memory</li><li>The empty string <code>''</code> acts as a delimiter when joining the reversed characters back together</li><li>Converting the final string to an integer with <code>int()</code> produces the reversed number</li></ul><p>This method shines when working with longer numbers since it conserves memory by processing one character at a time. It offers similar functionality to slice notation but with enhanced readability that clearly communicates the reversal intent.</p><h3>Using list comprehension</h3><pre><code>num = 9876
num_str = str(num)
reversed_str = &#x27;&#x27;.join([num_str[i] for i in range(len(num_str)-1, -1, -1)])
reversed_num = int(reversed_str)
print(reversed_num)</code></pre><pre><code>6789</code></pre><p>List comprehension offers a Pythonic way to reverse numbers by creating a new list of characters in reverse order. The <code>range()</code> function generates indices from the last character to the first, stepping backwards with <code>-1</code>. The comprehension builds a reversed sequence that <code>join()</code> combines into a string.</p><ul><li>The expression <code>range(len(num_str)-1, -1, -1)</code> creates a sequence starting from the last index, continuing until <code>-1</code>, moving backward one step at a time</li><li>The comprehension <code>[num_str[i] for i in range(...)]</code> accesses each character using these reversed indices</li><li>This approach gives you explicit control over the reversal process while maintaining readable, efficient code</li></ul><p>While this method requires more code than slice notation, it demonstrates how to leverage Python's list comprehension for custom sequence manipulation. The technique proves particularly valuable when you need to apply additional transformations during the reversal process.</p><h2>Mathematical approaches</h2><p>Beyond string manipulation, Python enables number reversal through pure mathematical operations, recursive functions, and functional programming with <code>reduce()</code>—each offering unique advantages for specific use cases.</p><h3>Using division and modulo operations</h3><pre><code>def reverse_number(num):
    reversed_num = 0
    while num &gt; 0:
        digit = num % 10
        reversed_num = reversed_num * 10 + digit
        num = num // 10
    return reversed_num

print(reverse_number(12345))</code></pre><pre><code>54321</code></pre><p>This mathematical approach extracts and rebuilds digits without converting to strings. The <code>reverse_number</code> function processes each digit through a loop using two key operations: modulo and integer division.</p><ul><li>The modulo operator <code>%</code> extracts the rightmost digit by finding the remainder when divided by 10</li><li>Integer division <code>//</code> removes the rightmost digit by dividing the number by 10</li><li>Each extracted digit gets added to <code>reversed_num</code> after multiplying by 10 to shift existing digits left</li></ul><p>For example, when reversing 12345, the function first extracts 5, then 4, then 3, and so on. It builds the reversed number by gradually constructing 5, then 54, then 543, until reaching the final result 54321.</p><h3>Using recursion</h3><pre><code>def reverse_recursive(num, reversed_num=0):
    if num == 0:
        return reversed_num
    return reverse_recursive(num // 10, reversed_num * 10 + num % 10)

print(reverse_recursive(12345))</code></pre><pre><code>54321</code></pre><p>The recursive approach elegantly breaks down number reversal into smaller, identical steps. Each recursive call processes one digit and builds the reversed result through the accumulator parameter <code>reversed_num</code>.</p><ul><li>The base case <code>if num == 0</code> returns the final reversed number when no digits remain</li><li>The recursive step uses <code>num // 10</code> to remove the rightmost digit and continue processing</li><li>The expression <code>reversed_num * 10 + num % 10</code> builds the reversed number one digit at a time</li></ul><p>For example, reversing 12345 creates a chain of recursive calls. Each call extracts a digit and positions it correctly in the final number through multiplication and addition. This technique showcases the power of recursion for breaking complex operations into simple, repeatable steps.</p><h3>Using functional programming with <code>reduce()</code></h3><pre><code>from functools import reduce

def reverse_functional(num):
    return reduce(lambda acc, digit: acc * 10 + int(digit), str(num)[::-1], 0)

print(reverse_functional(12345))</code></pre><pre><code>54321</code></pre><p>The <code>reduce()</code> function transforms a sequence into a single value by applying an operation repeatedly. In this case, it builds the reversed number digit by digit using a lambda function that multiplies the accumulator by 10 and adds each new digit.</p><ul><li>The <code>lambda acc, digit</code> function takes two parameters: <code>acc</code> stores the running total. <code>digit</code> represents each character from the reversed string</li><li>The <code>str(num)[::-1]</code> creates a reversed string of digits that <code>reduce()</code> processes from left to right</li><li>The final parameter <code>0</code> provides the initial value for the accumulator</li></ul><p>For example, when reversing 12345, <code>reduce()</code> processes the reversed string "54321". It starts with 0, then computes 5, then 50+4=54, then 540+3=543, continuing until it reaches 54321.</p><h3>Checking if a number is a palindrome using <code>str()</code> comparison</h3><p>The <code>str()</code> function enables a straightforward palindrome check by comparing a number with its reversed version—a technique that works efficiently for both small and large integers.</p><pre><code>def is_palindrome(num):
    return str(num) == str(num)[::-1]

test_numbers = [121, 12321, 12345, 98789]
for num in test_numbers:
    print(f&quot;{num} is{&#x27; &#x27; if is_palindrome(num) else &#x27; not &#x27;}a palindrome&quot;)</code></pre><p>The <code>is_palindrome</code> function efficiently determines if a number reads the same forwards and backwards. It converts the input number to a string and compares it with its reversed version using the slice operator <code>[::-1]</code>. The function returns <code>True</code> if both strings match, indicating a palindrome.</p><p>A loop processes a list of test numbers, using Python's ternary operator in an f-string to generate clear output messages. The expression <code>&#x27; &#x27; if is_palindrome(num) else &#x27; not &#x27;</code> elegantly adds or omits the word "not" based on the palindrome check result.</p><ul><li>Numbers like 121 and 12321 will return <code>True</code></li><li>Numbers like 12345 will return <code>False</code></li><li>The solution handles numbers of any length</li></ul><h3>Creating a simple number encoding scheme with <code>[::-1]</code> reversal</h3><p>Number reversal combined with basic arithmetic operations creates a straightforward encoding scheme that transforms account IDs and other sensitive numbers into less recognizable forms while maintaining reversibility.</p><pre><code>def encode_number(num, salt=7):
    reversed_num = int(str(num)[::-1])
    encoded = reversed_num * salt + salt
    return encoded

account_id = 12345
encoded_id = encode_number(account_id)
print(f&quot;Original ID: {account_id}, Encoded: {encoded_id}&quot;)</code></pre><p>The <code>encode_number</code> function implements a basic number transformation technique using two key operations. First, it reverses the input number using string conversion and the <code>[::-1]</code> slice operator. Then it applies a mathematical formula using a <code>salt</code> value (defaulting to 7) to further obscure the number.</p><ul><li>The function takes a number and an optional salt parameter</li><li>It multiplies the reversed number by the salt value</li><li>Finally, it adds the salt value to create the encoded result</li></ul><p>This approach creates a simple yet effective way to transform numbers while preserving the ability to decode them later. The salt value adds an extra layer of complexity to the transformation process.</p><h2>Common errors and challenges</h2><p>Python's number reversal operations can encounter several edge cases that require special handling—from preserving zeros to managing negative values effectively.</p><h3>Handling leading zeros in reversed numbers</h3><p>Leading zeros pose a unique challenge when reversing numbers in Python. The <code>int()</code> function automatically removes leading zeros, which can produce unexpected results when you need to preserve the original number of digits.</p><pre><code>num = 1020
reversed_num = int(str(num)[::-1])
print(f&quot;Original: {num}, Reversed: {reversed_num}&quot;)</code></pre><p>When reversing <code>1020</code>, the output becomes <code>201</code> instead of <code>0201</code>. This happens because Python's <code>int()</code> function drops leading zeros during the conversion process. The following code demonstrates a solution to preserve these zeros.</p><pre><code>num = 1020
reversed_str = str(num)[::-1]
print(f&quot;Original: {num}, Reversed as string: {reversed_str}, As number: {int(reversed_str)}&quot;)</code></pre><p>The solution stores the reversed number as a string using <code>reversed_str = str(num)[::-1]</code> before converting it to an integer. This preserves leading zeros in the string representation while still allowing numeric operations with the integer version.</p><ul><li>Watch for this issue when working with phone numbers, ZIP codes, or any data where leading zeros carry meaning</li><li>The string format maintains the exact digit count and position information</li><li>Use string comparison instead of numeric comparison when exact digit matching matters</li></ul><p>This approach gives you flexibility to handle both string and numeric representations based on your specific needs. The integer conversion remains available when you need to perform calculations.</p><h3>Handling negative numbers with <code>abs()</code> function</h3><p>Negative numbers require special handling during reversal operations. The <code>str()</code> method includes the minus sign when converting negative integers to strings. This creates unexpected behavior when using slice operations directly. The code below demonstrates this common pitfall.</p><pre><code>num = -12345
reversed_num = int(str(num)[::-1])
print(f&quot;Original: {num}, Reversed: {reversed_num}&quot;)</code></pre><p>The code incorrectly places the negative sign at the end of the reversed number, producing an invalid result. The direct string reversal fails to handle the minus symbol appropriately. The following implementation demonstrates the proper approach for negative numbers.</p><pre><code>num = -12345
abs_num = abs(num)
reversed_abs = int(str(abs_num)[::-1])
reversed_num = -reversed_abs if num &lt; 0 else reversed_abs
print(f&quot;Original: {num}, Reversed: {reversed_num}&quot;)</code></pre><p>The solution handles negative numbers by first using <code>abs()</code> to remove the minus sign. After reversing the absolute value, it reapplies the negative sign only if the original number was negative. This approach ensures proper placement of the minus sign in the final result.</p><ul><li>Watch for this issue when processing financial data or mathematical calculations that involve negative numbers</li><li>The ternary operator <code>-reversed_abs if num < 0 else reversed_abs</code> provides an elegant way to conditionally restore the sign</li><li>This pattern works consistently across different Python versions and number ranges</li></ul><h3>Preserving trailing zeros when using <code>int()</code> conversion</h3><p>Trailing zeros at the end of numbers present a distinct challenge when performing number reversal operations. The <code>int()</code> function automatically drops these zeros during conversion, potentially altering the expected output. The code below demonstrates this common issue that developers encounter when working with numbers that end in zero.</p><pre><code>num = 12300
reversed_num = int(str(num)[::-1])
print(f&quot;Original: {num}, Reversed: {reversed_num}&quot;)</code></pre><p>When reversing <code>12300</code>, the code produces <code>321</code> instead of <code>00321</code>. The <code>int()</code> function strips away the zeros that should appear at the start of the reversed number. Let's examine a solution that preserves these important digits.</p><pre><code>num = 12300
reversed_str = str(num)[::-1]
print(f&quot;Original: {num}, Reversed as string: {reversed_str}, As number: {int(reversed_str)}&quot;)</code></pre><p>The solution stores the reversed number in a string variable <code>reversed_str</code> before converting it to an integer. This approach preserves all zeros in the string representation while still allowing numeric operations with the integer version.</p><ul><li>Watch for this issue when working with formatted numbers like product codes or serial numbers</li><li>The string format maintains exact digit positions and counts</li><li>Use string comparison instead of numeric comparison when precise digit matching matters</li></ul><p>This pattern gives you flexibility to handle both string and numeric representations based on your specific needs. The integer conversion remains available when you need to perform calculations with the reversed number.</p></div></div></div><h2>FAQs</h2><div><div><h3>How do you reverse a number using string conversion in python?</h3><div><div><div><p>Converting a number to a string with <code>str()</code> lets you manipulate it as text. You can then reverse the characters using string slicing with <code>[::-1]</code>. This approach works because Python's string slicing treats the text as a sequence of individual characters.</p><p>To get back to a number, wrap the reversed string with <code>int()</code>. This method proves especially useful when you need to check for palindromic numbers or perform digit-based operations.</p></div></div></div></div></div><div><div><h3>What happens when you try to reverse a negative number?</h3><div><div><div><p>When you reverse a negative number like <code>-123</code>, the minus sign stays at the front while the digits reverse. So <code>-123</code> becomes <code>-321</code>. This happens because programming languages treat the minus sign as a separate operator rather than part of the number itself.</p><p>The process works in two steps: first isolating the absolute value to reverse the digits, then reapplying the negative sign. This approach maintains mathematical consistency and prevents unexpected behavior in calculations.</p></div></div></div></div></div><div><div><h3>Can you reverse a number without converting it to a string?</h3><div><div><div><p>Yes, you can reverse a number mathematically using modulo division and multiplication. The process extracts each digit from right to left using the <code>%</code> operator, then builds the reversed number by multiplying the running total by 10 and adding each new digit.</p><p>For example, to reverse 123: Extract 3 using <code>123 % 10</code>, multiply result (0) by 10 and add 3. Repeat with <code>12 % 10</code> to get 2, then <code>1 % 10</code> for 1. This builds 321.</p></div></div></div></div></div><div><div><h3>How do you handle leading zeros when reversing a number?</h3><div><div><div><p>Leading zeros vanish naturally during number reversal because we convert numbers to strings and back. When you convert <code>00123</code> to an integer, it becomes <code>123</code>. The solution depends on your needs. For precise string manipulation, store the original number as a string and handle zeros explicitly. For mathematical operations, leading zeros don't affect the result since <code>00123</code> and <code>123</code> are mathematically equivalent.</p><ul><li>Convert to string, count leading zeros</li><li>Reverse the digits</li><li>Add zeros back if needed</li></ul></div></div></div></div></div><div><div><h3>What&#x27;s the difference between using slicing and the reversed() function for numbers?</h3><div><div><div><p>String slicing with <code>[::-1]</code> creates a reversed copy by working directly with the string's memory layout, making it faster for small sequences. The <code>reversed()</code> function returns an iterator object that yields elements in reverse order without creating a new copy—this approach uses less memory for large sequences.</p><p>Both methods achieve the same result, but their performance characteristics differ based on your data size and access patterns. Slicing excels for small strings while <code>reversed()</code> shines when handling large sequences or when you need to process elements one at a time.</p></div></div></div></div></div><h2>🏠</h2></body></html>