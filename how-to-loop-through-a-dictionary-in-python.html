<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title>How to loop through a dictionary in Python</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@700&amp;family=Literata:wght@400;700&amp;family=Fira+Code:wght@400;700&amp;display=swap" rel="stylesheet" type="text/css" />
  <link href="styles.css" rel="stylesheet" type="text/css" />
</head><body id="top">
  <script src="script.js"></script>
<h1><a href="index.html">How to loop through a dictionary in Python</a></h1><div><div><div><p>Dictionaries in Python store key-value pairs that let you organize and access data efficiently. Understanding how to iterate through dictionaries unlocks powerful ways to process data structures and solve real-world programming challenges.</p><p>This guide covers essential dictionary looping techniques, practical tips, and debugging strategies, with code examples created using <a href="https://claude.ai/">Claude</a>, an AI assistant built by Anthropic.</p><h2>Basic iteration through a dictionary</h2><pre><code>my_dict = {&quot;apple&quot;: 1, &quot;banana&quot;: 2, &quot;cherry&quot;: 3}
for key in my_dict:
    print(f&quot;Key: {key}, Value: {my_dict[key]}&quot;)</code></pre><pre><code>Key: apple, Value: 1
Key: banana, Value: 2
Key: cherry, Value: 3</code></pre><p>The code demonstrates the most straightforward way to loop through a Python dictionary using a <code>for</code> loop. This method directly iterates over the dictionary's keys, which Python automatically provides when you use a dictionary in a loop context.</p><p>While this approach works, it requires an extra step to access values by using the key as an index (<code>my_dict[key]</code>). This makes the code slightly less efficient than alternative methods, especially when dealing with large dictionaries or performance-critical applications. The main advantages of this method include:</p><ul><li>Intuitive syntax that mirrors how we conceptually think about dictionaries</li><li>Direct access to keys for operations that primarily focus on key manipulation</li><li>Compatibility with older Python versions</li></ul><h2>Common dictionary iteration methods</h2><p>Python's dictionary methods <code>keys()</code>, <code>values()</code>, and <code>items()</code> provide more explicit and efficient ways to access dictionary components than basic iteration.</p><h3>Using the <code>keys()</code> method explicitly</h3><pre><code>my_dict = {&quot;apple&quot;: 1, &quot;banana&quot;: 2, &quot;cherry&quot;: 3}
for key in my_dict.keys():
    print(f&quot;The key is: {key}&quot;)</code></pre><pre><code>The key is: apple
The key is: banana
The key is: cherry</code></pre><p>The <code>keys()</code> method provides explicit access to dictionary keys as a view object. While this approach achieves the same result as basic iteration, it makes the code's intent clearer to other developers reading your code.</p><ul><li>The method returns a dynamic view of the dictionary's keys that automatically updates when the dictionary changes</li><li>It enables you to store the keys in a separate variable for repeated use without accessing the dictionary again</li><li>This approach particularly helps when you need to perform operations exclusively on keys or compare keys across different dictionaries</li></ul><p>The performance remains virtually identical to basic iteration since Python optimizes both approaches under the hood. Choose this method when you want to emphasize that you're specifically working with dictionary keys in your code.</p><h3>Looping through values with the <code>values()</code> method</h3><pre><code>my_dict = {&quot;apple&quot;: 1, &quot;banana&quot;: 2, &quot;cherry&quot;: 3}
for value in my_dict.values():
    print(f&quot;The value is: {value}&quot;)</code></pre><pre><code>The value is: 1
The value is: 2
The value is: 3</code></pre><p>The <code>values()</code> method provides direct access to a dictionary's values without needing to reference their keys. This approach streamlines your code when you only need to work with the stored data rather than the keys that organize it.</p><ul><li>The method returns a view object that dynamically updates whenever the dictionary changes</li><li>It's more memory efficient than creating a separate list of values</li><li>Python optimizes the iteration process behind the scenes for better performance</li></ul><p>When you call <code>my_dict.values()</code>, Python creates an iterator that yields each value in sequence. This eliminates the need to use bracket notation or maintain a separate counter variable while looping through the dictionary.</p><h3>Unpacking key-value pairs with the <code>items()</code> method</h3><pre><code>my_dict = {&quot;apple&quot;: 1, &quot;banana&quot;: 2, &quot;cherry&quot;: 3}
for key, value in my_dict.items():
    print(f&quot;{key} has a value of {value}&quot;)</code></pre><pre><code>apple has a value of 1
banana has a value of 2
cherry has a value of 3</code></pre><p>The <code>items()</code> method provides the most elegant way to access both keys and values simultaneously during dictionary iteration. It returns each key-value pair as a tuple that you can unpack directly in the <code>for</code> loop statement.</p><ul><li>Python automatically unpacks the tuple into the variables <code>key</code> and <code>value</code> at each iteration</li><li>This approach eliminates the need to use bracket notation or multiple method calls</li><li>The syntax reads naturally and makes your code's intent immediately clear</li></ul><p>While <code>items()</code> creates a view object like <code>keys()</code> and <code>values()</code>, it maintains efficiency by not copying the dictionary data. The method particularly shines when you need to perform operations that depend on both the key and its corresponding value.</p><h2>Advanced dictionary operations</h2><p>Building on these foundational iteration methods, Python dictionaries offer powerful features for transforming, viewing, and filtering data structures to solve complex programming challenges.</p><h3>Creating a new dictionary with dictionary comprehension</h3><pre><code>my_dict = {&quot;apple&quot;: 1, &quot;banana&quot;: 2, &quot;cherry&quot;: 3}
doubled_values = {k: v*2 for k, v in my_dict.items()}
print(doubled_values)</code></pre><pre><code>{&#x27;apple&#x27;: 2, &#x27;banana&#x27;: 4, &#x27;cherry&#x27;: 6}</code></pre><p>Dictionary comprehension offers a concise way to create new dictionaries by transforming existing ones. The syntax <code>{k: v*2 for k, v in my_dict.items()}</code> creates a new dictionary that doubles each value while keeping the original keys intact.</p><ul><li>The expression before <code>for</code> (<code>k: v*2</code>) defines how to construct each new key-value pair</li><li>The iteration part (<code>for k, v in my_dict.items()</code>) works through the source dictionary</li><li>Python applies the transformation to each element automatically</li></ul><p>This approach proves more readable and efficient than traditional loops when performing straightforward dictionary transformations. You'll often use it for data processing tasks like unit conversion or applying calculations across datasets.</p><h3>Working with dynamic dictionary view objects</h3><pre><code>my_dict = {&quot;apple&quot;: 1, &quot;banana&quot;: 2, &quot;cherry&quot;: 3}
keys_view = my_dict.keys()
my_dict[&quot;date&quot;] = 4
print(f&quot;Updated keys view: {keys_view}&quot;)</code></pre><pre><code>Updated keys view: dict_keys([&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;, &#x27;date&#x27;])</code></pre><p>Dictionary view objects provide a dynamic window into a dictionary's contents. When you create a view using methods like <code>keys()</code>, <code>values()</code>, or <code>items()</code>, that view automatically reflects any changes made to the original dictionary.</p><ul><li>The view object <code>keys_view</code> updates automatically when you add the new key <code>"date"</code> to <code>my_dict</code></li><li>Views don't create a separate copy of the data. They maintain a live connection to the dictionary</li><li>This behavior helps prevent data inconsistencies and reduces memory usage in your programs</li></ul><p>This dynamic updating proves particularly useful when you need to track dictionary changes across different parts of your code or when working with large datasets where copying data would be inefficient.</p><h3>Filtering dictionaries during iteration</h3><pre><code>my_dict = {&quot;apple&quot;: 1, &quot;banana&quot;: 2, &quot;cherry&quot;: 3, &quot;date&quot;: 4}
filtered_dict = {k: v for k, v in my_dict.items() if v % 2 == 0}
print(filtered_dict)</code></pre><pre><code>{&#x27;banana&#x27;: 2, &#x27;date&#x27;: 4}</code></pre><p>Dictionary comprehension with filtering combines transformation and selection in a single, elegant expression. The code creates a new dictionary containing only key-value pairs where the value is even, using the modulo operator <code>v % 2 == 0</code> as a filter condition.</p><ul><li>The <code>if</code> statement at the end acts as a filter, only including pairs that match your condition</li><li>Python evaluates this condition for each key-value pair during iteration</li><li>The resulting dictionary preserves the original structure while containing only the filtered elements</li></ul><p>This filtering technique proves especially useful when processing data sets where you need to extract specific items based on their values. It offers a more concise and readable alternative to traditional loop-based filtering.</p><h3>Counting word frequency with the <code>split()</code> method</h3><p>The <code>split()</code> method transforms text into a list of individual words, enabling us to build a dictionary that tracks how frequently each word appears in a given string.</p><pre><code>text = &quot;the quick brown fox jumps over the lazy dog&quot;
word_count = {}

for word in text.split():
    if word in word_count:
        word_count[word] += 1
    else:
        word_count[word] = 1
        
print(word_count)</code></pre><p>This code creates a dictionary to track how many times each word appears in a text string. The <code>split()</code> method breaks the string into individual words that we can process one by one.</p><p>The loop checks if each word exists as a key in <code>word_count</code>. When it finds a word for the first time, it adds that word to the dictionary with a count of 1. If the word already exists, it increments its count by 1.</p><ul><li>Empty dictionary <code>word_count</code> stores word-frequency pairs</li><li>Default count of 1 for new words using <code>word_count[word] = 1</code></li><li>Existing words get incremented through <code>word_count[word] += 1</code></li></ul><p>This pattern forms the foundation for many text analysis tasks where you need to count occurrences of items in a sequence.</p><h3>Calculating grade averages with nested dictionary iteration</h3><p>Nested dictionaries enable efficient grade tracking and analysis by storing each student's subject scores as inner dictionaries within a main grade book structure, which we can process using Python's <code>items()</code> method to calculate individual averages.</p><pre><code>grade_book = {
    &#x27;Alice&#x27;: {&#x27;math&#x27;: 90, &#x27;science&#x27;: 82, &#x27;history&#x27;: 88},
    &#x27;Bob&#x27;: {&#x27;math&#x27;: 85, &#x27;science&#x27;: 94, &#x27;history&#x27;: 76},
    &#x27;Charlie&#x27;: {&#x27;math&#x27;: 92, &#x27;science&#x27;: 88, &#x27;history&#x27;: 91}
}

for student, subjects in grade_book.items():
    total = sum(subjects.values())
    average = total / len(subjects)
    print(f&quot;{student}&#x27;s average grade: {average:.2f}&quot;)</code></pre><p>This code demonstrates nested dictionary iteration to process student grades efficiently. The outer dictionary uses student names as keys, while inner dictionaries store subject-specific grades. The <code>items()</code> method enables simultaneous access to both the student name and their grade dictionary in a single loop.</p><ul><li>The <code>subjects.values()</code> call extracts all grades for each student</li><li>Python's built-in <code>sum()</code> function calculates the total of these grades</li><li>The <code>len(subjects)</code> counts how many subjects each student takes</li></ul><p>The f-string formats the output with two decimal places using <code>:.2f</code>. This creates a clean, readable display of each student's average grade across all their subjects.</p><h2>Common errors and challenges</h2><p>Understanding common Python dictionary pitfalls helps you write more reliable code that handles errors gracefully and maintains data integrity during operations.</p><h3>Preventing <code>KeyError</code> when accessing dictionary keys</h3><p>A <code>KeyError</code> occurs when you try to access a dictionary key that doesn't exist. This common Python exception can crash your program if not handled properly. The code below demonstrates what happens when requesting a non-existent <code>"email"</code> key from a dictionary.</p><pre><code>user_data = {&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30}
email = user_data[&quot;email&quot;]  # This raises KeyError
print(f&quot;User email: {email}&quot;)</code></pre><p>The code attempts to directly access a dictionary key that doesn't exist in <code>user_data</code>. Python raises a <code>KeyError</code> because it can't find <code>"email"</code> in the dictionary. Let's examine a safer approach in the code below.</p><pre><code>user_data = {&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30}
email = user_data.get(&quot;email&quot;, &quot;Not provided&quot;)
print(f&quot;User email: {email}&quot;)  # Outputs: User email: Not provided</code></pre><p>The <code>get()</code> method provides a safer way to access dictionary values by accepting a default value as its second argument. When Python can't find the requested key, it returns this default instead of raising an error. This approach maintains your code's flow while gracefully handling missing data.</p><ul><li>Watch for this error when working with user input or external data sources</li><li>Consider using <code>get()</code> when a key's existence is uncertain</li><li>The default value helps maintain data consistency in your program</li></ul><p>This pattern proves especially valuable when processing data from APIs or user forms where some fields might be optional or empty.</p><h3>Avoiding <code>RuntimeError</code> when modifying during iteration</h3><p>Modifying a dictionary while iterating through it can trigger a <code>RuntimeError</code>. This common issue occurs when you attempt to add or remove dictionary items during a <code>for</code> loop. The code below demonstrates how deleting even-numbered values causes Python to raise this error.</p><pre><code>numbers = {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4}
for key in numbers:
    if numbers[key] % 2 == 0:
        del numbers[key]  # RuntimeError: dictionary changed during iteration</code></pre><p>Python's dictionary iterator expects the dictionary structure to remain stable during iteration. When the code removes items with <code>del</code>, it disrupts this expectation and crashes the loop. The following code demonstrates a safer approach to this operation.</p><pre><code>numbers = {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4}
keys_to_delete = [k for k, v in numbers.items() if v % 2 == 0]
for key in keys_to_delete:
    del numbers[key]
print(numbers)  # {&#x27;a&#x27;: 1, &#x27;c&#x27;: 3}</code></pre><p>This solution creates a separate list of keys to remove before modifying the dictionary. The list comprehension <code>[k for k, v in numbers.items() if v % 2 == 0]</code> identifies all keys with even values first. Then a separate loop removes these keys safely because we're not modifying the dictionary during its own iteration.</p><ul><li>Watch for this error when filtering dictionaries based on their values</li><li>Be cautious when using <code>del</code> or <code>pop</code> operations inside dictionary loops</li><li>Consider creating a new dictionary instead of modifying the existing one if you need to preserve the original data</li></ul><p>This pattern works well for any situation where you need to remove multiple items from a dictionary based on specific conditions. The two-step approach ensures reliable execution without runtime errors.</p><h3>Using <code>dict.update()</code> or <code>**</code> for merging dictionaries</h3><p>Python dictionaries don't support direct addition with the <code>+</code> operator like lists do. When developers attempt to combine dictionaries using <code>+</code>, Python raises a <code>TypeError</code>. The code below demonstrates this common mistake and its resulting error message.</p><pre><code>dict1 = {&quot;a&quot;: 1, &quot;b&quot;: 2}
dict2 = {&quot;b&quot;: 3, &quot;c&quot;: 4}
merged = dict1 + dict2  # TypeError: unsupported operand type(s) for +</code></pre><p>The <code>+</code> operator doesn't understand how to combine dictionary data structures. Python strictly reserves this operator for mathematical addition and sequence concatenation. The code below demonstrates the correct approach to merging dictionaries.</p><pre><code>dict1 = {&quot;a&quot;: 1, &quot;b&quot;: 2}
dict2 = {&quot;b&quot;: 3, &quot;c&quot;: 4}
merged = {**dict1, **dict2}  # Python 3.5+
print(merged)  # {&#x27;a&#x27;: 1, &#x27;b&#x27;: 3, &#x27;c&#x27;: 4}</code></pre><p>The double asterisk operator <code>**</code> unpacks each dictionary's key-value pairs into the new dictionary. When dictionaries share keys, the rightmost dictionary's values take precedence. In this case, <code>dict2</code>'s value for key <code>'b'</code> (3) overwrites <code>dict1</code>'s value (2).</p><ul><li>Watch for this pattern when combining data from multiple sources</li><li>Consider which dictionary should take precedence for duplicate keys</li><li>Use <code>dict.update()</code> as an alternative method for dictionary merging</li></ul><p>This approach works seamlessly with any number of dictionaries. Simply add more <code>**</code> expressions to merge additional dictionaries in your preferred order.</p></div></div></div><h2>FAQs</h2><div><div><h3>What is the difference between using items() and keys() when iterating through a dictionary?</h3><div><div><div><p>The <code>items()</code> method returns both keys and values as tuples, letting you access the complete dictionary data in a single loop. In contrast, <code>keys()</code> only returns the dictionary's keys—you'll need an extra lookup step to get values.</p><ul><li>Use <code>items()</code> when you need both pieces: <code>for key, value in dict.items()</code></li><li>Choose <code>keys()</code> when you only care about the identifiers: <code>for key in dict.keys()</code></li></ul><p>This difference impacts performance with large dictionaries. <code>items()</code> creates a view object that uses more memory but saves processing time by avoiding repeated lookups.</p></div></div></div></div></div><div><div><h3>How can I access both the key and value simultaneously while looping?</h3><div><div><div><p>Python's <code>items()</code> method provides direct access to both keys and values in a dictionary. When you loop with <code>for key, value in dict.items()</code>, Python automatically unpacks each key-value pair into separate variables.</p><ul><li>The <code>items()</code> method returns tuples containing each key and its corresponding value</li><li>Python's tuple unpacking handles the assignment seamlessly during iteration</li><li>This approach eliminates the need for separate dictionary lookups, making your code more efficient and readable</li></ul></div></div></div></div></div><div><div><h3>What happens if I modify a dictionary while iterating through it?</h3><div><div><div><p>Modifying a dictionary during iteration can cause unpredictable behavior and raise a <code>RuntimeError</code>. Python's dictionary view objects track changes to the underlying dictionary. When you add or remove items while looping, the iterator loses its place—leading to skipped elements or crashes.</p><ul><li>Adding new keys may or may not be included in the current iteration</li><li>Deleting keys can make Python skip the next item</li><li>Modifying existing values is safe and won't disrupt iteration</li></ul><p>To safely modify a dictionary during iteration, create a new dictionary or work with a copy of the keys list.</p></div></div></div></div></div><div><div><h3>Can I loop through dictionary values without accessing the keys?</h3><div><div><div><p>Yes, Python's dictionaries offer multiple ways to loop through values directly. The <code>values()</code> method returns a view of all values, letting you iterate without touching the keys. This approach saves memory since it doesn't create a separate list.</p><ul><li>Use <code>for value in dictionary.values()</code> for the most straightforward iteration</li><li>The view object updates automatically when the dictionary changes</li><li>This method proves especially useful when working with large dictionaries where you need to process only the values</li></ul></div></div></div></div></div><div><div><h3>How do I iterate through a dictionary in a specific order?</h3><div><div><div><p>Python dictionaries maintain insertion order by default since version 3.7. You can iterate through keys using <code>dict.keys()</code>, values with <code>dict.values()</code>, or both using <code>dict.items()</code>. For custom sorting, convert the dictionary items to a list and use <code>sorted()</code> with a key function to define the order.</p><ul><li>Sort by keys: <code>sorted(my_dict.items())</code></li><li>Sort by values: <code>sorted(my_dict.items(), key=lambda x: x[1])</code></li></ul><p>This approach gives you complete control over the iteration order while maintaining the dictionary's structure.</p></div></div></div></div></div><h2>🏠</h2></body></html>