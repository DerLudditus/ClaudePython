<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title>How to compare two dictionaries in Python</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@700&amp;family=Literata:wght@400;700&amp;family=Fira+Code:wght@400;700&amp;display=swap" rel="stylesheet" type="text/css" />
  <link href="styles.css" rel="stylesheet" type="text/css" />
</head><body id="top">
  <script src="script.js"></script>
<h1><a href="index.html">How to compare two dictionaries in Python</a></h1><div><div><div><p>Comparing Python dictionaries efficiently helps developers validate data consistency, track state changes, and identify discrepancies between datasets. Python provides multiple built-in methods and operators to compare dictionary contents and structures.</p><p>This guide covers essential comparison techniques, practical tips, and real-world applications, with code examples created using <a href="https://claude.ai/">Claude</a>, an AI assistant built by Anthropic.</p><h2>Using the equality operator (<code>==</code>)</h2><pre><code>dict1 = {&#x27;a&#x27;: 1, &#x27;b&#x27;: 2}
dict2 = {&#x27;b&#x27;: 2, &#x27;a&#x27;: 1}
dict3 = {&#x27;a&#x27;: 1, &#x27;b&#x27;: 3}
print(dict1 == dict2)  # Order doesn&#x27;t matter
print(dict1 == dict3)  # Values matter</code></pre><pre><code>True
False</code></pre><p>The equality operator <code>==</code> compares dictionary contents without considering the order of key-value pairs. This behavior makes it particularly useful when validating data consistency across different sources where the insertion sequence might vary.</p><p>The example demonstrates two key aspects of dictionary comparison:</p><ul><li>Order-independence: <code>dict1</code> and <code>dict2</code> contain identical key-value pairs in different orders, yet evaluate as equal</li><li>Value sensitivity: <code>dict1</code> and <code>dict3</code> share the same keys but differ in one value, resulting in inequality</li></ul><h2>Basic comparison techniques</h2><p>Beyond basic equality checks, Python offers specialized dictionary comparison methods like <code>is</code>, <code>items()</code>, and subset validation to handle more nuanced data validation scenarios.</p><h3>Comparing dictionary identity with the <code>is</code> operator</h3><pre><code>dict1 = {&#x27;a&#x27;: 1, &#x27;b&#x27;: 2}
dict2 = {&#x27;a&#x27;: 1, &#x27;b&#x27;: 2}
dict3 = dict1
print(dict1 is dict2)  # Different objects with same content
print(dict1 is dict3)  # Same object (reference)</code></pre><pre><code>False
True</code></pre><p>The <code>is</code> operator checks if two dictionaries reference the exact same object in memory rather than comparing their contents. When you create two separate dictionaries with identical key-value pairs like <code>dict1</code> and <code>dict2</code>, they occupy different memory locations and return <code>False</code> when compared with <code>is</code>.</p><p>However, when you assign <code>dict3 = dict1</code>, both variables point to the same dictionary object in memory. This creates a reference rather than a copy. That's why <code>dict1 is dict3</code> returns <code>True</code>.</p><ul><li>Use <code>is</code> to check dictionary identity when you need to verify if two variables reference the same object</li><li>Use <code>==</code> instead when you want to compare dictionary contents regardless of memory location</li></ul><h3>Comparing dictionary entries with <code>items()</code></h3><pre><code>dict1 = {&#x27;a&#x27;: 1, &#x27;b&#x27;: 2}
dict2 = {&#x27;a&#x27;: 1, &#x27;c&#x27;: 3}
common_items = set(dict1.items()) &amp; set(dict2.items())
diff_items = set(dict1.items()) - set(dict2.items())
print(f&quot;Common items: {common_items}&quot;)
print(f&quot;Items in dict1 but not in dict2: {diff_items}&quot;)</code></pre><pre><code>Common items: {(&#x27;a&#x27;, 1)}
Items in dict1 but not in dict2: {(&#x27;b&#x27;, 2)}</code></pre><p>The <code>items()</code> method converts dictionary key-value pairs into a set-compatible format, enabling powerful set operations for comparison. Converting dictionaries to sets unlocks efficient ways to find common elements and differences between them.</p><ul><li>The <code>&</code> operator identifies shared key-value pairs between dictionaries, stored in <code>common_items</code></li><li>The <code>-</code> operator finds key-value pairs unique to the first dictionary, stored in <code>diff_items</code></li><li>This approach proves especially useful when comparing complex dictionaries or tracking data changes over time</li></ul><p>In the example, both dictionaries share the pair <code>('a', 1)</code>. The pair <code>('b', 2)</code> exists only in <code>dict1</code>, making it appear in the difference set.</p><h3>Checking if one dictionary is a subset of another</h3><pre><code>dict1 = {&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3}
dict2 = {&#x27;a&#x27;: 1, &#x27;b&#x27;: 2}
is_subset = all(item in dict1.items() for item in dict2.items())
print(f&quot;dict2 is a subset of dict1: {is_subset}&quot;)
print(f&quot;Keys in dict1 not in dict2: {dict1.keys() - dict2.keys()}&quot;)</code></pre><pre><code>dict2 is a subset of dict1: True
Keys in dict1 not in dict2: {&#x27;c&#x27;}</code></pre><p>The <code>all()</code> function elegantly checks if every key-value pair in <code>dict2</code> exists within <code>dict1</code>. When all pairs match, we consider <code>dict2</code> a subset of <code>dict1</code>.</p><ul><li>The generator expression <code>item in dict1.items() for item in dict2.items()</code> compares each pair efficiently without creating intermediate lists</li><li>The set operation <code>dict1.keys() - dict2.keys()</code> reveals which keys exist exclusively in <code>dict1</code></li><li>This pattern proves invaluable when validating data completeness or verifying that one dictionary contains all required entries from another</li></ul><p>In the example, <code>dict2</code> qualifies as a subset because its key-value pairs <code>'a': 1</code> and <code>'b': 2</code> exist in <code>dict1</code>. Meanwhile, <code>'c'</code> appears only in <code>dict1</code>.</p><h2>Advanced comparison methods</h2><p>Building on the foundational comparison techniques, Python offers sophisticated methods to handle nested data structures, selective key validation, and flexible numeric comparisons with customizable thresholds.</p><h3>Deep comparison for nested dictionaries</h3><pre><code>import json
dict1 = {&#x27;a&#x27;: 1, &#x27;b&#x27;: {&#x27;x&#x27;: 1, &#x27;y&#x27;: 2}}
dict2 = {&#x27;a&#x27;: 1, &#x27;b&#x27;: {&#x27;y&#x27;: 2, &#x27;x&#x27;: 1}}  # Same content, different order
dict3 = {&#x27;b&#x27;: {&#x27;x&#x27;: 1, &#x27;y&#x27;: 2}, &#x27;a&#x27;: 1}  # Same content, different order
print(json.dumps(dict1) == json.dumps(dict2))  # String comparison preserves order
print(dict1 == dict3)  # Dictionary comparison ignores order</code></pre><pre><code>False
True</code></pre><p>When comparing nested dictionaries, Python's standard equality operator <code>==</code> treats nested structures intelligently. It recursively compares all levels while maintaining order-independence, as shown by <code>dict1 == dict3</code> returning <code>True</code>.</p><p>The <code>json.dumps()</code> method offers a different approach by converting dictionaries to JSON strings. Since string comparison is order-sensitive, <code>json.dumps(dict1) == json.dumps(dict2)</code> returns <code>False</code> despite containing identical data.</p><ul><li>Use <code>==</code> when you need to compare nested dictionary contents regardless of order</li><li>Choose <code>json.dumps()</code> comparison when order matters or when you need to verify exact structural matches</li><li>Both methods handle nested structures automatically without requiring manual recursion</li></ul><h3>Comparing specific dictionary keys</h3><pre><code>dict1 = {&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 30, &#x27;city&#x27;: &#x27;New York&#x27;}
dict2 = {&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 25, &#x27;country&#x27;: &#x27;USA&#x27;}
keys_to_compare = [&#x27;name&#x27;, &#x27;age&#x27;]
match = all(dict1.get(k) == dict2.get(k) for k in keys_to_compare)
print(f&quot;Dictionaries match on specified keys: {match}&quot;)</code></pre><pre><code>Dictionaries match on specified keys: False</code></pre><p>Selective key comparison lets you validate specific dictionary fields while ignoring others. The <code>get()</code> method safely retrieves values even if a key doesn't exist, returning <code>None</code> instead of raising an error.</p><ul><li>The <code>keys_to_compare</code> list defines which fields to check—in this case only <code>'name'</code> and <code>'age'</code></li><li>The <code>all()</code> function with a generator expression efficiently checks if every specified key matches between dictionaries</li><li>The comparison returns <code>False</code> because while the names match, the ages differ (30 vs 25)</li></ul><p>This pattern proves especially useful when comparing data records where only certain fields matter for validation. The different city and country values don't affect the result since they aren't in <code>keys_to_compare</code>.</p><h3>Custom comparison with tolerance using dictionary comprehension</h3><pre><code>dict1 = {&#x27;a&#x27;: 10, &#x27;b&#x27;: 20, &#x27;c&#x27;: 30}
dict2 = {&#x27;a&#x27;: 11, &#x27;b&#x27;: 19, &#x27;c&#x27;: 31}
# Check if values are within ±2 of each other
tolerance_match = all(abs(dict1[k] - dict2[k]) &lt;= 2 for k in dict1 if k in dict2)
print(f&quot;Values match within tolerance: {tolerance_match}&quot;)</code></pre><pre><code>Values match within tolerance: True</code></pre><p>Custom tolerance comparison enables flexible matching between dictionary values that are close but not exactly equal. The <code>abs()</code> function calculates the absolute difference between corresponding values, while the <code>all()</code> function ensures every pair falls within the specified tolerance of ±2.</p><ul><li>The generator expression <code>abs(dict1[k] - dict2[k]) <= 2</code> checks if the difference between values is 2 or less</li><li>The condition <code>k in dict2</code> safely handles cases where keys exist in one dictionary but not the other</li><li>This approach proves valuable when comparing numerical data that may have minor variations due to rounding or measurement differences</li></ul><p>In the example, all values in <code>dict2</code> differ from <code>dict1</code> by only 1, so the comparison returns <code>True</code>. This technique offers more flexibility than strict equality checks when working with real-world data.</p><h3>Tracking user profile changes with dictionary comparison</h3><p>Dictionary comparison enables precise tracking of user profile updates by identifying changed fields, modified values, and new or removed attributes in social platforms and content management systems.</p><pre><code>old_profile = {&#x27;name&#x27;: &#x27;John&#x27;, &#x27;bio&#x27;: &#x27;Python developer&#x27;, &#x27;followers&#x27;: 120}
new_profile = {&#x27;name&#x27;: &#x27;John&#x27;, &#x27;bio&#x27;: &#x27;Python &amp; JS developer&#x27;, &#x27;followers&#x27;: 145}
keys_to_check = set(old_profile) | set(new_profile)
changes = {k: (old_profile.get(k), new_profile.get(k)) for k in keys_to_check 
          if old_profile.get(k) != new_profile.get(k)}
print(f&quot;Profile changes: {changes}&quot;)</code></pre><p>This code efficiently detects changes between two profile dictionaries. The <code>set()</code> function converts dictionary keys to sets while the <code>|</code> operator combines them into a unified set of all possible keys. A dictionary comprehension then creates <code>changes</code>, which stores only the modified values as tuples.</p><p>The <code>get()</code> method safely handles missing keys by returning <code>None</code> instead of raising errors. The comparison runs only when values differ between profiles.</p><ul><li>The output shows both the old and new values for each changed field</li><li>The code gracefully handles cases where keys exist in one profile but not the other</li><li>This approach scales well for dictionaries of any size</li></ul><h3>Visualizing dictionary differences with the <code>difflib</code> module</h3><p>Python's <code>difflib</code> module provides a powerful way to visualize differences between dictionaries by converting them into human-readable, line-by-line comparisons that highlight changes, additions, and removals.</p><pre><code>import difflib

config1 = {&#x27;debug&#x27;: True, &#x27;api_url&#x27;: &#x27;api.example.com&#x27;, &#x27;timeout&#x27;: 30}
config2 = {&#x27;debug&#x27;: False, &#x27;api_url&#x27;: &#x27;api.example.com&#x27;, &#x27;retry&#x27;: 3}
config1_items = [f&quot;{k}: {v}&quot; for k, v in sorted(config1.items())]
config2_items = [f&quot;{k}: {v}&quot; for k, v in sorted(config2.items())]
diff = difflib.ndiff(config1_items, config2_items)
print(&#x27;\n&#x27;.join(list(diff)))</code></pre><p>The code demonstrates a practical way to compare two configuration dictionaries and visualize their differences. The <code>difflib</code> module's <code>ndiff()</code> function analyzes text-based differences between sequences. First, the code converts each dictionary into a sorted list of formatted strings using list comprehension with <code>f"{k}: {v}"</code>.</p><ul><li>The <code>sorted()</code> function ensures consistent ordering of dictionary items</li><li>The <code>join()</code> method with <code>\n</code> creates a clean, line-by-line output</li><li>The resulting diff shows added, removed, or modified configuration values with special markers</li></ul><p>This approach makes it easy to spot configuration changes at a glance. It's particularly useful when comparing complex dictionaries or tracking changes in configuration files.</p><h2>Common errors and challenges</h2><p>Dictionary comparison in Python requires careful handling of missing keys, complex data types, and copy operations to avoid common runtime errors and unexpected behavior.</p><h3>Avoiding <code>KeyError</code> when comparing dictionaries with missing keys</h3><p>Direct dictionary key access with square bracket notation raises a <code>KeyError</code> when a key doesn't exist. This common pitfall occurs when comparing dictionaries with different key sets. The code below demonstrates how accessing a missing key interrupts program execution.</p><pre><code>def compare_values(dict1, dict2, key):
    return dict1[key] == dict2[key]

user1 = {&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;email&#x27;: &#x27;alice@example.com&#x27;}
user2 = {&#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;phone&#x27;: &#x27;555-1234&#x27;}

print(compare_values(user1, user2, &#x27;email&#x27;))  # KeyError: &#x27;email&#x27;</code></pre><p>The <code>compare_values()</code> function directly accesses dictionary keys without checking their existence first. When <code>user2</code> lacks the <code>'email'</code> key, Python raises a <code>KeyError</code>. The code below demonstrates a safer approach to handle missing keys.</p><pre><code>def compare_values(dict1, dict2, key):
    return key in dict1 and key in dict2 and dict1[key] == dict2[key]

user1 = {&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;email&#x27;: &#x27;alice@example.com&#x27;}
user2 = {&#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;phone&#x27;: &#x27;555-1234&#x27;}

print(compare_values(user1, user2, &#x27;email&#x27;))  # False</code></pre><p>The improved code checks for key existence before attempting comparison. By using the <code>in</code> operator and logical AND (<code>and</code>), the function first verifies that both dictionaries contain the key. Only then does it compare the values.</p><ul><li>Always verify key existence when comparing dictionaries with potentially different structures</li><li>The <code>get()</code> method offers an alternative approach by returning <code>None</code> for missing keys</li><li>This pattern prevents runtime errors in data validation scenarios where dictionary contents may vary</li></ul><p>Watch for this issue when working with user input, API responses, or any data source where dictionary structure isn't guaranteed consistent.</p><h3>Handling <code>TypeError</code> when comparing complex dictionary values</h3><p>Comparing dictionary values containing different data types like lists and sets can trigger a <code>TypeError</code>. This common issue occurs when applying set operations between incompatible collection types. The code below demonstrates how mixing lists and sets leads to runtime errors.</p><pre><code>user1 = {&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;tags&#x27;: [&#x27;python&#x27;, &#x27;data&#x27;]}
user2 = {&#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;tags&#x27;: {&#x27;python&#x27;, &#x27;web&#x27;}}

common_tags = user1[&#x27;tags&#x27;] &amp; user2[&#x27;tags&#x27;]  # TypeError: unsupported operand
print(f&quot;Common tags: {common_tags}&quot;)</code></pre><p>The error occurs because the <code>&</code> operator can't directly compare a list and a set. Lists don't support set operations. The code attempts to find common elements between two different collection types. Let's examine the corrected implementation below.</p><pre><code>user1 = {&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;tags&#x27;: [&#x27;python&#x27;, &#x27;data&#x27;]}
user2 = {&#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;tags&#x27;: {&#x27;python&#x27;, &#x27;web&#x27;}}

common_tags = set(user1[&#x27;tags&#x27;]) &amp; set(user2[&#x27;tags&#x27;])
print(f&quot;Common tags: {common_tags}&quot;)  # {&#x27;python&#x27;}</code></pre><p>Converting both collections to sets before comparison solves the <code>TypeError</code>. The <code>set()</code> function transforms any iterable into a set, enabling the use of set operations like <code>&</code> to find common elements. This approach works because sets only contain unique values and support efficient intersection operations.</p><ul><li>Watch for this error when comparing dictionary values containing different collection types</li><li>Common scenarios include processing user tags, categories, or any nested data structures</li><li>Always verify the data types of nested collections before applying set operations</li></ul><p>The solution proves especially useful when dealing with data from multiple sources where collection types might vary. Converting to sets standardizes the comparison process.</p><h3>Shallow vs. deep copy confusion in dictionary comparisons</h3><p>Python's shallow copy mechanism can lead to unexpected behavior when comparing nested dictionaries. The <code>copy()</code> method only creates a surface-level duplicate, leaving nested objects sharing the same memory reference. The code below demonstrates how modifying a nested value affects both the original and copied dictionaries.</p><pre><code>original = {&#x27;user&#x27;: {&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;score&#x27;: 85}}
copy = original.copy()  # Shallow copy
copy[&#x27;user&#x27;][&#x27;score&#x27;] = 90

print(original == copy)  # True, but original was modified!
print(original)  # {&#x27;user&#x27;: {&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;score&#x27;: 90}}</code></pre><p>The shallow copy creates a new dictionary that still references the same nested <code>user</code> dictionary in memory. When modifying nested values, both dictionaries change because they share that reference. Let's examine the corrected implementation using deep copy.</p><pre><code>import copy
original = {&#x27;user&#x27;: {&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;score&#x27;: 85}}
deep_copy = copy.deepcopy(original)  # Deep copy
deep_copy[&#x27;user&#x27;][&#x27;score&#x27;] = 90

print(original == deep_copy)  # False
print(original)  # {&#x27;user&#x27;: {&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;score&#x27;: 85}}</code></pre><p>The <code>copy.deepcopy()</code> function creates a completely independent copy of a dictionary and all its nested objects. Unlike shallow copying with <code>.copy()</code>, deep copying ensures that modifying nested values in the copy won't affect the original dictionary.</p><ul><li>Deep copying recursively duplicates every object in the dictionary hierarchy</li><li>Each nested dictionary gets its own memory space</li><li>Changes to nested values remain isolated between copies</li></ul><p>Watch for this issue when working with dictionaries containing nested data structures like lists, dictionaries, or custom objects. The problem commonly surfaces in data processing pipelines where you need to preserve the original data while making modifications to a copy.</p></div></div></div><h2>FAQs</h2><div><div><h3>What happens when I use the == operator to compare two dictionaries?</h3><div><div><div><p>When you use the <code>==</code> operator to compare dictionaries in Python, it checks if both dictionaries contain exactly the same key-value pairs. The comparison returns <code>True</code> only when all keys match and their corresponding values are equal.</p><p>The order of items doesn't matter since dictionaries are unordered collections. Python performs this comparison by iterating through each key-value pair and verifying equality. This makes dictionary comparison particularly useful for checking data equivalence in configuration files or API responses.</p></div></div></div></div></div><div><div><h3>How can I check if two dictionaries have the same keys but different values?</h3><div><div><div><p>To compare dictionary keys while ignoring values, use the <code>keys()</code> method with a direct equality check. The <code>set()</code> function converts key collections into sets, enabling a clean comparison that ignores order.</p><ul><li>The expression <code>set(dict1.keys()) == set(dict2.keys())</code> returns <code>True</code> when dictionaries share identical keys</li><li>This approach works because sets only contain unique elements and their order doesn't matter</li><li>For value comparison, you can use <code>dict1[key] != dict2[key]</code> to identify differences</li></ul><p>This method efficiently handles dictionaries of any size while maintaining readable, maintainable code.</p></div></div></div></div></div><div><div><h3>Can I compare dictionaries that contain nested lists or other dictionaries?</h3><div><div><div><p>Yes, Python can directly compare nested dictionaries and lists using the <code>==</code> operator. The comparison works recursively, checking each nested element for equality. Two dictionaries match when they contain identical key-value pairs, regardless of order.</p><p>Python performs a deep comparison by default. When you use <code>==</code>, it traverses through all nested structures to verify that corresponding elements match exactly. This behavior makes it straightforward to compare complex data structures without writing custom comparison logic.</p></div></div></div></div></div><div><div><h3>What&#x27;s the difference between using &#x27;is&#x27; and == when comparing dictionaries?</h3><div><div><div><p>The <code>is</code> operator checks if two dictionaries reference the exact same object in memory, while <code>==</code> compares their contents. Two dictionaries with identical key-value pairs will return <code>True</code> with <code>==</code> but <code>False</code> with <code>is</code> if they're separate objects.</p><p>This distinction matters when you need to verify dictionary identity rather than equality. Python creates new dictionary objects even when their contents match. Understanding this behavior helps prevent subtle bugs in reference comparisons.</p></div></div></div></div></div><div><div><h3>How do I find which key-value pairs are different between two dictionaries?</h3><div><div><div><p>Python's <code>dict</code> objects offer several methods to compare dictionaries. The <code>items()</code> method converts dictionary entries into a set-like view, enabling direct comparison. You can find differences using set operations:</p><ul><li>Use <code>dict1.items() - dict2.items()</code> to find key-value pairs unique to the first dictionary</li><li>Use <code>dict2.items() - dict1.items()</code> to find pairs unique to the second dictionary</li></ul><p>This approach works efficiently because Python optimizes set operations for performance. The resulting sets contain tuples of differing key-value pairs, making it easy to identify exactly what changed between the dictionaries.</p></div></div></div></div></div><h2>🏠</h2></body></html>