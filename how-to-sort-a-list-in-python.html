<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title>How to sort a list in Python</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@700&amp;family=Literata:wght@400;700&amp;family=Fira+Code:wght@400;700&amp;display=swap" rel="stylesheet" type="text/css" />
  <link href="styles.css" rel="stylesheet" type="text/css" />
</head><body id="top">
  <script src="script.js"></script>
<h1><a href="index.html">How to sort a list in Python</a></h1><div><div><div><p>Python's list sorting capabilities empower developers to organize data efficiently. The language provides built-in methods like <code>sort()</code> and <code>sorted()</code> that handle both simple lists and complex data structures with remarkable flexibility.</p><p>This guide covers essential sorting techniques, optimization tips, and practical examples—all created with <a href="https://claude.ai/">Claude</a>, an AI assistant built by Anthropic. You'll learn proven strategies for implementing robust sorting solutions.</p><h2>Basic list sorting with <code>sort()</code> method</h2><pre><code>numbers = [5, 2, 8, 1, 9]
numbers.sort()
print(numbers)</code></pre><pre><code>[1, 2, 5, 8, 9]</code></pre><p>The <code>sort()</code> method modifies lists in-place, permanently reordering the original elements in ascending order. This approach consumes less memory than creating a new sorted list, making it ideal for large datasets where performance matters.</p><p>Python's sorting algorithm uses Timsort—a hybrid sorting algorithm that combines the best features of merge sort and insertion sort. The method automatically handles different data types intelligently:</p><ul><li>Numbers sort numerically (1 comes before 2)</li><li>Strings sort alphabetically (a comes before b)</li><li>Mixed-type comparisons follow Python's default ordering rules</li></ul><h2>Common sorting techniques</h2><p>Building on Python's <code>sort()</code> method, three additional techniques unlock even more powerful ways to organize your data with precision and flexibility.</p><h3>Sorting with the <code>sorted()</code> function</h3><pre><code>original = [5, 2, 8, 1, 9]
sorted_list = sorted(original)
print(&quot;Original:&quot;, original)
print(&quot;Sorted:&quot;, sorted_list)</code></pre><pre><code>Original: [5, 2, 8, 1, 9]
Sorted: [1, 2, 5, 8, 9]</code></pre><p>Unlike <code>sort()</code>, the <code>sorted()</code> function creates a new list containing the sorted elements while preserving the original list unchanged. This non-destructive approach gives you more flexibility when you need to maintain both sorted and unsorted versions of your data.</p><ul><li>The function returns a fresh list with elements arranged in ascending order</li><li>Your original list remains exactly as it was before sorting</li><li>You can assign the sorted result to any variable name you choose</li></ul><p>This approach requires slightly more memory since it creates a new list. However, it offers a cleaner solution when you need to preserve the original data order while working with a sorted version.</p><h3>Sorting in reverse order</h3><pre><code>numbers = [5, 2, 8, 1, 9]
numbers.sort(reverse=True)
print(numbers)</code></pre><pre><code>[9, 8, 5, 2, 1]</code></pre><p>The <code>reverse=True</code> parameter flips Python's default ascending sort order, arranging elements from highest to lowest. This straightforward approach works with both the <code>sort()</code> method and <code>sorted()</code> function.</p><ul><li>Numbers arrange from largest to smallest (9 down to 1)</li><li>Strings order from Z to A</li><li>The operation modifies the list directly, just like regular sorting</li></ul><p>You'll often need descending order when building leaderboards, displaying recent items first, or prioritizing tasks. The <code>reverse</code> parameter offers a cleaner solution than sorting normally and then reversing the list afterward.</p><h3>Sorting with custom keys</h3><pre><code>fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;date&quot;, &quot;elderberry&quot;]
fruits.sort(key=len)
print(fruits)</code></pre><pre><code>[&#x27;date&#x27;, &#x27;apple&#x27;, &#x27;cherry&#x27;, &#x27;banana&#x27;, &#x27;elderberry&#x27;]</code></pre><p>The <code>key</code> parameter transforms how Python compares elements during sorting. In this example, <code>key=len</code> tells Python to sort the fruits based on their length instead of alphabetically.</p><ul><li>Shorter words like "date" (4 letters) appear before longer ones like "elderberry" (10 letters)</li><li>The <code>key</code> function processes each element before comparison</li><li>Python applies the <code>key</code> function to all items but preserves the original values in the output</li></ul><p>This powerful feature enables custom sorting logic for complex data structures. You can use any function that returns a comparable value as the key—including lambda functions for more sophisticated sorting criteria.</p><h2>Advanced sorting approaches</h2><p>Building on the flexibility of custom keys, Python offers three powerful approaches that give developers precise control over complex sorting scenarios—from concise lambda functions to versatile operator modules.</p><h3>Sorting with lambda functions</h3><pre><code>people = [(&quot;Alice&quot;, 25), (&quot;Bob&quot;, 19), (&quot;Charlie&quot;, 32)]
people.sort(key=lambda x: x[1])
print(people)</code></pre><pre><code>[(&#x27;Bob&#x27;, 19), (&#x27;Alice&#x27;, 25), (&#x27;Charlie&#x27;, 32)]</code></pre><p>Lambda functions enable quick, one-line sorting rules without defining a separate function. In this example, <code>key=lambda x: x[1]</code> tells Python to sort the list of tuples based on the second element (index 1) of each tuple—the age values 19, 25, and 32.</p><ul><li>The <code>x</code> parameter represents each tuple in the list during sorting</li><li><code>x[1]</code> extracts the age value from each tuple</li><li>Python automatically uses these extracted values to determine the final order</li></ul><p>The result shows the tuples arranged by increasing age, with Bob (19) first and Charlie (32) last. The original tuple structure remains intact. This approach works especially well when you need to sort complex data structures based on specific elements or calculated values.</p><h3>Sorting with <code>functools.cmp_to_key</code></h3><pre><code>from functools import cmp_to_key

def compare(a, b):
    return a % 10 - b % 10  # Sort by last digit

numbers = [15, 32, 48, 27, 91]
sorted_numbers = sorted(numbers, key=cmp_to_key(compare))
print(sorted_numbers)</code></pre><pre><code>[91, 32, 15, 27, 48]</code></pre><p>The <code>cmp_to_key</code> function transforms a comparison function into a key function that Python's sorting algorithms can use. In this example, the <code>compare</code> function sorts numbers based on their last digit using the modulo operator <code>%</code>.</p><ul><li>The comparison function takes two parameters (<code>a</code> and <code>b</code>) and returns a negative, zero, or positive value</li><li>A negative return value means <code>a</code> should come before <code>b</code></li><li>The modulo operation <code>% 10</code> extracts the last digit from each number</li></ul><p>When Python sorts the list <code>[15, 32, 48, 27, 91]</code>, it arranges numbers so their last digits appear in ascending order: 91 (1), 32 (2), 15 (5), 27 (7), 48 (8). This technique proves especially useful when implementing custom comparison logic that can't be achieved with a simple key function.</p><h3>Sorting with the <code>operator</code> module</h3><pre><code>import operator

students = [{&quot;name&quot;: &quot;Alice&quot;, &quot;grade&quot;: 85}, {&quot;name&quot;: &quot;Bob&quot;, &quot;grade&quot;: 92}, {&quot;name&quot;: &quot;Charlie&quot;, &quot;grade&quot;: 78}]
sorted_students = sorted(students, key=operator.itemgetter(&quot;grade&quot;), reverse=True)
print(sorted_students)</code></pre><pre><code>[{&#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;grade&#x27;: 92}, {&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;grade&#x27;: 85}, {&#x27;name&#x27;: &#x27;Charlie&#x27;, &#x27;grade&#x27;: 78}]</code></pre><p>The <code>operator</code> module provides efficient tools for sorting complex data structures. The <code>itemgetter()</code> function creates a callable object that retrieves specific dictionary values, making it ideal for sorting lists of dictionaries.</p><ul><li>The <code>key=operator.itemgetter("grade")</code> parameter tells Python to sort based on the grade values</li><li>Setting <code>reverse=True</code> arranges students from highest to lowest grade</li><li>This approach is more performant than using lambda functions for dictionary key access</li></ul><p>The output shows students sorted by their grades in descending order, with Bob's 92 first and Charlie's 78 last. This clean, readable solution works especially well when sorting large datasets of dictionaries or similar nested data structures.</p><h3>Sorting files by modification date with <code>os.path.getmtime()</code></h3><p>The <code>os.path.getmtime()</code> function enables Python to sort files based on their last modification timestamp, creating an organized view of your file system's history that reveals which files you've recently changed.</p><pre><code>import os
from datetime import datetime

files = os.listdir(&#x27;.&#x27;)
files.sort(key=lambda x: os.path.getmtime(x))
for file in files[:3]:  # Print first 3 files (oldest)
    mod_time = datetime.fromtimestamp(os.path.getmtime(file))
    print(f&quot;{file}: {mod_time.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;)}&quot;)</code></pre><p>This code retrieves and displays the three oldest files in your current directory. The <code>os.listdir('.')</code> function gathers all files, while <code>sort()</code> with a lambda function orders them by modification time. The modification timestamp comes from <code>os.path.getmtime()</code>, which returns seconds since the epoch.</p><ul><li>The <code>datetime.fromtimestamp()</code> converts raw timestamps into readable dates</li><li>The <code>strftime()</code> method formats these dates into a clear year-month-day hour:minute:second pattern</li><li>The slice <code>files[:3]</code> selects only the first three entries from the sorted list</li></ul><p>This approach creates a simple yet effective way to track your oldest files and understand your directory's chronological structure.</p><h3>Creating a leaderboard with multiple <code>sorted()</code> criteria</h3><p>Python's sorting capabilities enable you to build sophisticated leaderboards that rank players by multiple criteria—first by their score in descending order and then by completion time when scores are equal.</p><pre><code>players = [
    {&quot;name&quot;: &quot;Alice&quot;, &quot;score&quot;: 192, &quot;time&quot;: 45.2},
    {&quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 192, &quot;time&quot;: 39.8},
    {&quot;name&quot;: &quot;Charlie&quot;, &quot;score&quot;: 156, &quot;time&quot;: 42.1},
    {&quot;name&quot;: &quot;Diana&quot;, &quot;score&quot;: 218, &quot;time&quot;: 38.6}
]

# Sort by score (descending) and time (ascending) for ties
leaderboard = sorted(players, key=lambda x: (-x[&quot;score&quot;], x[&quot;time&quot;]))
for rank, player in enumerate(leaderboard, 1):
    print(f&quot;{rank}. {player[&#x27;name&#x27;]}: {player[&#x27;score&#x27;]} pts ({player[&#x27;time&#x27;]}s)&quot;)</code></pre><p>This code implements a sophisticated sorting system for a list of player dictionaries. The <code>sorted()</code> function uses a tuple-based <code>key</code> parameter to establish a two-tier ranking system.</p><p>The negative sign in <code>-x["score"]</code> reverses the score sorting order to achieve descending ranking. When players have equal scores, Python automatically moves to the second tuple element <code>x["time"]</code> to break ties. The <code>enumerate()</code> function then assigns sequential ranking numbers starting from 1.</p><ul><li>Higher scores take precedence over lower ones</li><li>For identical scores, faster completion times win</li><li>The output displays each player's rank, name, score, and time in a formatted string</li></ul><h2>Common errors and challenges</h2><p>Python's sorting operations can trigger three common errors that frustrate developers: type mismatches, immutable sequence modifications, and missing dictionary keys.</p><h3>Dealing with <code>TypeError</code> when sorting mixed types</h3><p>Python raises a <code>TypeError</code> when you attempt to compare incompatible data types during sorting operations. The error commonly occurs when mixing strings and numbers in the same list. This straightforward example demonstrates what happens when Python tries to sort elements that can't be naturally compared.</p><pre><code>mixed_list = [5, &quot;apple&quot;, 10, &quot;banana&quot;, 2]
mixed_list.sort()
print(mixed_list)</code></pre><p>Python can't directly compare strings with integers, so attempting to sort a list containing both types triggers a <code>TypeError</code>. The code below demonstrates an effective way to handle mixed-type sorting.</p><pre><code>mixed_list = [5, &quot;apple&quot;, 10, &quot;banana&quot;, 2]
numbers = sorted([x for x in mixed_list if isinstance(x, int)])
strings = sorted([x for x in mixed_list if isinstance(x, str)])
result = numbers + strings
print(result)</code></pre><p>This solution separates mixed-type elements into distinct lists using list comprehension and <code>isinstance()</code> type checking. The code creates two filtered lists: one for integers and another for strings. After sorting each list independently, it combines them with the <code>+</code> operator to produce a clean final result.</p><ul><li>Watch for this error when working with data from external sources like CSV files or user input</li><li>The error commonly appears when processing spreadsheet data where numbers are accidentally stored as strings</li><li>Consider converting all elements to the same type before sorting if uniformity matters for your use case</li></ul><h3>Handling the <code>AttributeError</code> with immutable sequences</h3><p>Python's <code>sort()</code> method only works with mutable sequences like lists. When you try to sort an immutable sequence like a tuple, Python raises an <code>AttributeError</code>. The code below demonstrates this common pitfall when working with tuples.</p><pre><code>data_tuple = (5, 2, 8, 1, 9)
data_tuple.sort()
print(data_tuple)</code></pre><p>The <code>sort()</code> method attempts to modify the tuple directly. Since tuples are immutable Python objects that prevent changes after creation, Python raises an <code>AttributeError</code>. Let's examine the correct approach in the following example.</p><pre><code>data_tuple = (5, 2, 8, 1, 9)
sorted_data = sorted(data_tuple)
print(sorted_data)
sorted_tuple = tuple(sorted(data_tuple))
print(sorted_tuple)</code></pre><p>The <code>sorted()</code> function creates a new list containing the sorted elements, solving the immutability problem. You can convert the result back to a tuple using the <code>tuple()</code> function if needed. This approach works because <code>sorted()</code> doesn't try to modify the original sequence.</p><ul><li>Watch for this error when working with data structures from external libraries that return tuples</li><li>Remember that strings and ranges are also immutable sequences that can't use <code>sort()</code></li><li>Consider whether you need the result as a tuple or if a sorted list meets your needs</li></ul><p>This pattern appears frequently when processing database results or working with named tuples in data analysis tasks. Always check if your sequence is mutable before attempting to sort it directly.</p><h3>Handling dictionaries with missing <code>key</code> values</h3><p>When sorting dictionaries by specific keys, Python raises a <code>KeyError</code> if any dictionary lacks the sorting key. This common issue often surfaces when processing incomplete data from databases or CSV files. The code below demonstrates what happens when sorting a list of student records where one entry lacks a grade.</p><pre><code>students = [
    {&quot;name&quot;: &quot;Alice&quot;, &quot;grade&quot;: 85},
    {&quot;name&quot;: &quot;Bob&quot;},  # Missing &quot;grade&quot; key
    {&quot;name&quot;: &quot;Charlie&quot;, &quot;grade&quot;: 78}
]
students.sort(key=lambda x: x[&quot;grade&quot;])
print(students)</code></pre><p>The <code>sort()</code> operation fails because it can't access the <code>grade</code> key in Bob's dictionary. When Python encounters the missing key, it immediately raises a <code>KeyError</code>. The code below demonstrates a robust solution for handling incomplete dictionary data.</p><pre><code>students = [
    {&quot;name&quot;: &quot;Alice&quot;, &quot;grade&quot;: 85},
    {&quot;name&quot;: &quot;Bob&quot;},  # Missing &quot;grade&quot; key
    {&quot;name&quot;: &quot;Charlie&quot;, &quot;grade&quot;: 78}
]
students.sort(key=lambda x: x.get(&quot;grade&quot;, 0))
print(students)</code></pre><p>The <code>get()</code> method provides a safer way to access dictionary values by returning a default value (0 in this case) when a key doesn't exist. This approach prevents <code>KeyError</code> exceptions and ensures smooth sorting even with incomplete data.</p><ul><li>Watch for this error when processing data from external sources like APIs or user submissions</li><li>Consider setting meaningful default values based on your sorting requirements</li><li>Use this pattern whenever you're unsure about data completeness or consistency</li></ul><p>The solution places entries with missing values at the start of the sorted list. You can adjust the default value in <code>get()</code> to control where incomplete records appear in your final sort order.</p></div></div></div><h2>FAQs</h2><div><div><h3>What is the difference between sort() and sorted() when working with lists?</h3><div><div><div><p>The key difference lies in how these functions modify your data. <code>sort()</code> changes the original list directly and returns <code>None</code>, while <code>sorted()</code> creates a new sorted list without altering the original. This behavior reflects Python's distinction between in-place operations and functions that return new objects.</p><ul><li>Use <code>sort()</code> when you want to permanently reorder your list and save memory</li><li>Choose <code>sorted()</code> when you need to preserve the original list order or chain operations together</li></ul></div></div></div></div></div><div><div><h3>How can you sort a list in descending order instead of ascending?</h3><div><div><div><p>To sort a list in descending order, add the <code>reverse=True</code> parameter to Python's built-in <code>sort()</code> method or use the <code>sorted()</code> function. This tells Python to arrange elements from highest to lowest instead of the default lowest to highest.</p><ul><li>For lists, use <code>my_list.sort(reverse=True)</code> to modify the original list directly</li><li>For a new sorted copy, use <code>sorted(my_list, reverse=True)</code></li></ul><p>The <code>reverse</code> parameter works by inverting the comparison operations Python uses during the sorting process. This approach maintains the efficiency of Python's sorting algorithm while giving you the flexibility to sort in either direction.</p></div></div></div></div></div><div><div><h3>Can you sort a list that contains both numbers and strings together?</h3><div><div><div><p>Python's default <code>sort()</code> and <code>sorted()</code> functions can't directly compare numbers and strings. When you try this, Python raises a <code>TypeError</code> because it doesn't know how to compare these different data types meaningfully.</p><p>To sort mixed lists, you'll need to implement a custom sorting key that handles each type appropriately. The most common approach uses a tuple key that first groups items by type, then sorts within each type. This preserves a natural ordering while preventing type comparison errors.</p></div></div></div></div></div><div><div><h3>What happens to the original list when you use the sort() method?</h3><div><div><div><p>The <code>sort()</code> method modifies the original list directly instead of creating a new sorted copy. This in-place sorting means the list's elements get rearranged in their memory locations. When you call <code>sort()</code>, Python's algorithm compares and swaps elements until they're in the specified order.</p><p>Understanding this behavior is crucial for memory efficiency. Since Python doesn't need to allocate new memory for a copy, in-place sorting works well for large datasets. However, if you need to preserve the original order, use the <code>sorted()</code> function instead—it returns a new sorted list while leaving the original untouched.</p></div></div></div></div></div><div><div><h3>How do you sort a list of strings alphabetically ignoring case sensitivity?</h3><div><div><div><p>To sort strings alphabetically while ignoring case, use the <code>sort()</code> method with a key function that converts each string to lowercase. The <code>key=str.lower</code> parameter tells the sorting algorithm to compare lowercase versions of the strings while maintaining their original case in the output. This approach works because Python's string comparison follows Unicode ordering—making it reliable across different character sets.</p><p>The sorting process happens in two logical steps: first converting each string temporarily to lowercase for comparison, then rearranging the original strings based on those lowercase comparisons. This preserves the original formatting while achieving case-insensitive ordering.</p></div></div></div></div></div><h2>🏠</h2></body></html>