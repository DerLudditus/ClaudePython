<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><title>How to make a set in Python</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@700&amp;family=Literata:wght@400;700&amp;family=Fira+Code:wght@400;700&amp;display=swap" rel="stylesheet" type="text/css" />
  <link href="styles.css" rel="stylesheet" type="text/css" />
</head><body id="top">
  <script src="script.js"></script>
<h1><a href="index.html">How to make a set in Python</a></h1><div><div><div><p>Python sets provide a powerful way to store unique, unordered collections of items. These built-in data structures enable efficient membership testing, mathematical operations, and duplicate elimination through methods like <code>add()</code>, <code>remove()</code>, and <code>intersection()</code>.</p><p>This guide covers essential techniques for working with sets, practical applications, and debugging tips. All code examples were created with <a href="https://claude.ai/">Claude</a>, an AI assistant built by Anthropic.</p><h2>Creating a simple set</h2><pre><code>fruits = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;}
print(fruits)
print(type(fruits))</code></pre><pre><code>{&#x27;cherry&#x27;, &#x27;banana&#x27;, &#x27;apple&#x27;}
&lt;class &#x27;set&#x27;&gt;</code></pre><p>The code demonstrates two key approaches to creating Python sets. The curly brace syntax <code>{}</code> offers a more concise way to define sets compared to using the <code>set()</code> constructor. This literal notation mirrors how developers write mathematical sets, making the code more intuitive and readable.</p><p>The output reveals important characteristics of Python sets:</p><ul><li>Elements appear in an arbitrary order, highlighting the unordered nature of sets</li><li>Python automatically handles duplicate removal during set creation</li><li>The <code>type()</code> function confirms the data structure is a native <code>set</code> object</li></ul><h2>Basic set creation and modification</h2><p>Building on these fundamentals, Python sets support flexible creation from existing data structures and offer intuitive methods like <code>add()</code> and <code>remove()</code> for modifying set contents.</p><h3>Creating sets from other data structures</h3><pre><code>numbers_list = [1, 2, 2, 3, 4, 4, 5]
numbers_set = set(numbers_list)
print(&quot;Original list:&quot;, numbers_list)
print(&quot;Set from list:&quot;, numbers_set)</code></pre><pre><code>Original list: [1, 2, 2, 3, 4, 4, 5]
Set from list: {1, 2, 3, 4, 5}</code></pre><p>The <code>set()</code> constructor efficiently transforms any iterable data structure into a set. In this example, it converts a list containing duplicate numbers into a set with unique values.</p><ul><li>Python automatically removes duplicate values (2 and 4) during the conversion process</li><li>The original order isn't preserved since sets are unordered by design</li><li>The <code>set()</code> constructor works with other iterables too including tuples, strings, and dictionaries</li></ul><p>This conversion pattern proves especially useful when you need to quickly eliminate duplicates from existing collections or perform set operations on your data. The <code>set()</code> constructor handles all the complexity of duplicate removal and data structure conversion internally.</p><h3>Adding elements with <code>add()</code> and <code>update()</code></h3><pre><code>colors = {&quot;red&quot;, &quot;green&quot;}
colors.add(&quot;blue&quot;)
colors.update([&quot;yellow&quot;, &quot;orange&quot;])
print(colors)</code></pre><pre><code>{&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;yellow&#x27;, &#x27;orange&#x27;, &#x27;green&#x27;}</code></pre><p>Python sets provide two primary methods for adding elements. The <code>add()</code> method inserts a single item, while <code>update()</code> lets you add multiple elements at once from any iterable like lists or tuples.</p><ul><li>Use <code>add()</code> for inserting individual elements. The code example shows this with <code>colors.add("blue")</code></li><li>Choose <code>update()</code> when you need to add multiple items simultaneously. The example demonstrates this by adding both "yellow" and "orange" in one operation</li><li>Both methods automatically handle duplicates. If you try to add an element that already exists in the set, Python simply ignores it</li></ul><p>These methods maintain the set's core property of storing only unique values while offering flexible ways to expand your data collection.</p><h3>Removing elements with <code>remove()</code>, <code>discard()</code>, and <code>pop()</code></h3><pre><code>animals = {&quot;dog&quot;, &quot;cat&quot;, &quot;bird&quot;, &quot;fish&quot;}
animals.remove(&quot;bird&quot;)
animals.discard(&quot;elephant&quot;)
popped = animals.pop()
print(&quot;After modifications:&quot;, animals)
print(&quot;Popped element:&quot;, popped)</code></pre><pre><code>After modifications: {&#x27;cat&#x27;, &#x27;dog&#x27;}
Popped element: fish</code></pre><p>Python offers three distinct methods to remove elements from sets. Each serves a specific purpose and handles errors differently.</p><ul><li>The <code>remove()</code> method deletes a specific element. It raises a <code>KeyError</code> if the element doesn't exist in the set</li><li>Use <code>discard()</code> when you want to safely remove an element without raising errors. The code shows this by attempting to remove "elephant" which doesn't exist in the set</li><li>The <code>pop()</code> method removes and returns an arbitrary element from the set. Since sets are unordered, you can't predict which element it will remove</li></ul><p>In the example, <code>remove()</code> deletes "bird", <code>discard()</code> safely attempts to remove a non-existent "elephant", and <code>pop()</code> removes "fish". The final set contains only "cat" and "dog".</p><h2>Advanced set techniques and operations</h2><p>Building on these foundational set operations, Python provides advanced techniques like set comprehensions, immutable <code>frozenset</code> objects, and mathematical operators that enable sophisticated data manipulation and analysis.</p><h3>Using set comprehensions</h3><pre><code>squares = {x**2 for x in range(1, 6)}
even_squares = {x**2 for x in range(1, 11) if x % 2 == 0}
print(&quot;Squares:&quot;, squares)
print(&quot;Even squares:&quot;, even_squares)</code></pre><pre><code>Squares: {1, 4, 9, 16, 25}
Even squares: {4, 16, 36, 64, 100}</code></pre><p>Set comprehensions provide a concise way to create sets using a single line of code. The syntax mirrors list comprehensions but uses curly braces instead of square brackets.</p><ul><li>The first example <code>{x**2 for x in range(1, 6)}</code> creates a set of squared numbers from 1 to 5</li><li>The second example adds a conditional statement <code>if x % 2 == 0</code> to filter for even numbers only</li><li>Python evaluates the expression <code>x**2</code> for each value that meets the conditions</li></ul><p>Set comprehensions automatically handle duplicate removal. They excel at creating sets from mathematical sequences or filtered data. This makes them particularly useful for data transformation and mathematical operations where uniqueness matters.</p><h3>Working with immutable <code>frozenset</code></h3><pre><code>regular_set = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}
frozen = frozenset(regular_set)
print(frozen)
fs1 = frozenset([1, 2, 3])
fs2 = frozenset([3, 4, 5])
print(fs1.intersection(fs2))</code></pre><pre><code>frozenset({&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;})
frozenset({3})</code></pre><p>The <code>frozenset</code> creates an immutable version of a regular set. Once created, you can't modify its contents. This immutability makes <code>frozenset</code> objects perfect for use as dictionary keys or elements within other sets.</p><ul><li>The code converts a regular set of letters into a <code>frozenset</code> using the <code>frozenset()</code> constructor</li><li>Despite being immutable, <code>frozenset</code> objects support all non-modifying set operations like <code>intersection()</code></li><li>The example demonstrates this by finding the common element (3) between two <code>frozenset</code> objects</li></ul><p>Think of a <code>frozenset</code> as a read-only snapshot of your data. It preserves the uniqueness property of sets while preventing accidental modifications that could break your program's logic.</p><h3>Set operations with operators</h3><pre><code>set_a = {1, 2, 3, 4, 5}
set_b = {4, 5, 6, 7, 8}
print(&quot;Union:&quot;, set_a | set_b)
print(&quot;Intersection:&quot;, set_a &amp; set_b)
print(&quot;Difference (A-B):&quot;, set_a - set_b)
print(&quot;Symmetric difference:&quot;, set_a ^ set_b)</code></pre><pre><code>Union: {1, 2, 3, 4, 5, 6, 7, 8}
Intersection: {4, 5}
Difference (A-B): {1, 2, 3}
Symmetric difference: {1, 2, 3, 6, 7, 8}</code></pre><p>Python sets support mathematical operations through intuitive operators that mirror standard set theory notation. The vertical bar <code>|</code> creates a union containing all unique elements from both sets. The ampersand <code>&</code> finds common elements through intersection.</p><ul><li>The minus operator <code>-</code> returns elements present in the first set but not in the second</li><li>Use the caret <code>^</code> for symmetric difference. This operation returns elements present in either set but not in both</li><li>These operators provide a more readable alternative to method calls like <code>union()</code> or <code>intersection()</code></li></ul><p>The example demonstrates how two overlapping sets <code>{1, 2, 3, 4, 5}</code> and <code>{4, 5, 6, 7, 8}</code> combine and compare through these operators. Python automatically handles the complexity of set operations while maintaining uniqueness in the results.</p><h3>Finding unique words in text processing</h3><p>Python sets excel at extracting unique elements from text data through the <code>set()</code> constructor and <code>split()</code> method, enabling efficient word frequency analysis and duplicate removal in natural language processing tasks.</p><pre><code>text = &quot;to be or not to be that is the question&quot;
words = text.split()
unique_words = set(words)
print(&quot;Original text:&quot;, text)
print(&quot;Unique words:&quot;, unique_words)
print(f&quot;Word count: {len(words)}, Unique word count: {len(unique_words)}&quot;)</code></pre><p>This code demonstrates efficient text analysis using Python's string and set operations. The <code>split()</code> function first breaks the input text into a list of individual words. Converting this list to a set with <code>set(words)</code> automatically removes any duplicate words while preserving unique ones.</p><ul><li>The <code>len(words)</code> shows the total count of words including duplicates</li><li>The <code>len(unique_words)</code> reveals how many distinct words appear in the text</li><li>The f-string provides a clean way to display both counts in a single line</li></ul><p>This pattern proves especially valuable when analyzing larger texts where manual duplicate tracking becomes impractical. The set's automatic deduplication handles all the complexity behind the scenes.</p><h3>Finding common friends with <code>intersection()</code> in social networks</h3><p>The <code>intersection()</code> method efficiently identifies mutual connections between social network users by finding common elements between friend sets, enabling features like friend suggestions and shared connection analysis.</p><pre><code>user1_friends = {&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;, &quot;David&quot;, &quot;Eve&quot;}
user2_friends = {&quot;Bob&quot;, &quot;Charlie&quot;, &quot;Frank&quot;, &quot;Grace&quot;, &quot;Heidi&quot;}
common_friends = user1_friends.intersection(user2_friends)
unique_to_user1 = user1_friends - user2_friends
print(f&quot;Common friends: {common_friends}&quot;)
print(f&quot;Friends unique to User 1: {unique_to_user1}&quot;)
print(f&quot;Total unique friends: {user1_friends | user2_friends}&quot;)</code></pre><p>This code demonstrates three key set operations for analyzing relationships between two friend groups. The <code>intersection()</code> method finds mutual friends "Bob" and "Charlie" that both users share. The subtraction operator <code>-</code> identifies friends exclusive to the first user. Finally, the union operator <code>|</code> combines both friend lists into a single set of all unique friends.</p><ul><li>The <code>intersection()</code> reveals overlapping connections</li><li>The subtraction shows who only User 1 knows</li><li>The union provides a complete network view without duplicates</li></ul><p>These operations efficiently process friend relationships while automatically handling duplicate names and maintaining data uniqueness.</p><h2>Common errors and challenges</h2><p>Python sets can trigger specific errors during common operations like iteration, type handling, and indexing. Understanding these challenges helps you write more reliable code.</p><h3>Avoiding <code>RuntimeError</code> when modifying a set during iteration</h3><p>Modifying a set while iterating through it can trigger a <code>RuntimeError</code>. This common pitfall occurs when you try to change set contents using methods like <code>remove()</code> or <code>add()</code> during a <code>for</code> loop. The following code demonstrates this error in action.</p><pre><code>numbers = {1, 2, 3, 4, 5}
for num in numbers:
    if num % 2 == 0:
        numbers.remove(num)  # This causes RuntimeError
print(numbers)</code></pre><p>Python's set iterator expects the collection to remain stable during iteration. When <code>remove()</code> deletes elements mid-loop, it disrupts this stability and triggers the error. Let's examine a safer approach in the code below.</p><pre><code>numbers = {1, 2, 3, 4, 5}
numbers_to_remove = {num for num in numbers if num % 2 == 0}
numbers -= numbers_to_remove
print(numbers)</code></pre><p>The solution creates a separate set using a set comprehension to identify elements for removal first. Then it uses the subtraction operator <code>-=</code> to modify the original set in one clean operation. This approach avoids the <code>RuntimeError</code> by preventing direct modification during iteration.</p><ul><li>Watch for this error when filtering or modifying sets based on their contents</li><li>The pattern applies to any situation where you need to remove multiple elements based on a condition</li><li>Consider using set comprehensions or temporary collections when you need to modify sets based on their current contents</li></ul><h3>Handling unhashable types in sets with <code>TypeError</code></h3><p>Python sets require all elements to be hashable, meaning they have a consistent hash value that never changes. When you try to add mutable objects like lists or dictionaries to a set, Python raises a <code>TypeError</code>. The following code demonstrates this common pitfall.</p><pre><code>my_set = {1, 2, 3}
my_set.add([4, 5, 6])  # Lists are unhashable - TypeError
print(my_set)</code></pre><p>Lists contain multiple values that can change over time. This mutability makes them incompatible with Python's hashing system, which requires stable values. The code below demonstrates the proper approach to handle this scenario.</p><pre><code>my_set = {1, 2, 3}
my_set.update([4, 5, 6])  # update() adds individual elements
print(my_set)</code></pre><p>The <code>update()</code> method provides a safer way to add multiple elements to a set. Instead of trying to insert an entire list as a single element, it adds each item individually. This approach avoids the <code>TypeError</code> that occurs when attempting to add unhashable types like lists or dictionaries.</p><ul><li>Watch for this error when working with complex data structures like lists of lists or nested dictionaries</li><li>Remember that sets can only contain immutable elements like numbers, strings, or tuples</li><li>Consider converting mutable objects to immutable ones before adding them to sets</li></ul><p>When designing data structures that use sets, plan ahead for the types of elements you'll store. This prevents runtime errors and maintains data integrity throughout your program's execution.</p><h3>Remembering that sets can't be accessed with index notation</h3><p>Unlike lists or tuples, Python sets don't support index-based access with square bracket notation <code>[]</code>. Attempting to retrieve elements by position triggers a <code>TypeError</code>. The code below demonstrates this common mistake when developers try accessing set elements like they would with ordered sequences.</p><pre><code>fruits = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;}
print(fruits[0])  # TypeError: &#x27;set&#x27; object is not subscriptable</code></pre><p>Sets store elements in an arbitrary order that can change between program runs. When you try to access elements with an index like <code>fruits[0]</code>, Python can't determine which element should be "first." The following code demonstrates the proper way to work with set elements.</p><pre><code>fruits = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;}
fruits_list = list(fruits)
print(fruits_list[0])  # Convert to list for indexing</code></pre><p>Converting a set to a list with <code>list(fruits)</code> provides a simple workaround when you need index-based access to elements. This approach creates an ordered sequence that supports traditional indexing while preserving the original set's unique values.</p><ul><li>Watch for this error when porting code from lists to sets</li><li>Remember that sets prioritize uniqueness and membership testing over ordered access</li><li>Consider whether you truly need index-based access. Sets excel at different operations like checking if elements exist or removing duplicates</li></ul><p>If your code frequently needs both unique values and ordered access, maintain parallel data structures. Keep the set for uniqueness operations and a separate list for indexed lookups.</p></div></div></div><h2>FAQs</h2><div><div><h3>How do you create an empty set in Python?</h3><div><div><div><p>Python offers two ways to create an empty set. The recommended approach uses the <code>set()</code> constructor function, which explicitly creates a new empty set object. While you might think using empty curly braces <code>{}</code> would work, this actually creates an empty dictionary instead.</p><p>The <code>set()</code> constructor creates a mutable, unordered collection that can store unique elements. This makes sets ideal for eliminating duplicates from sequences or performing mathematical set operations like unions and intersections.</p></div></div></div></div></div><div><div><h3>What&#x27;s the difference between using set() and curly braces for creating sets?</h3><div><div><div><p>Both <code>set()</code> and curly braces <code>{}</code> create sets in Python, but they serve different purposes. The <code>set()</code> constructor converts any iterable into a set, making it ideal for transforming lists or tuples. Curly braces create sets directly from comma-separated values, offering a cleaner syntax for writing sets literally.</p><p>Here's what makes them unique:</p><ul><li><code>set()</code> accepts a single iterable argument, enabling operations like removing duplicates from sequences</li><li>Curly braces <code>{}</code> provide a more readable way to write sets directly in code</li><li>Empty curly braces <code>{}</code> create dictionaries instead of sets. Use <code>set()</code> to create empty sets</li></ul></div></div></div></div></div><div><div><h3>Can you add duplicate values to a set?</h3><div><div><div><p>No, you can't add duplicate values to a set. Sets store unique values by design, making them perfect for removing duplicates from data. When you attempt to add a duplicate value using <code>add()</code>, the set silently ignores it instead of raising an error.</p><p>This behavior makes sets highly efficient for tasks like finding unique elements in a list or checking for membership. The set's uniqueness constraint comes from its hash-based implementation, which enables constant-time lookups and insertions while automatically handling duplicates.</p></div></div></div></div></div><div><div><h3>How do you convert a list to a set?</h3><div><div><div><p>Converting a list to a set transforms your data into a collection of unique elements. The <code>set()</code> function efficiently removes duplicates while maintaining only distinct values. This process creates an unordered collection that's perfect for membership testing and eliminating redundancy.</p><ul><li>Use <code>my_set = set(my_list)</code> for a direct conversion</li><li>Sets store each value exactly once, regardless of how many times it appeared in the original list</li><li>The conversion automatically handles deduplication for you</li></ul><p>Sets excel at rapid lookups and uniqueness checks because they use hash tables internally. This makes them significantly faster than scanning through lists for duplicates.</p></div></div></div></div></div><div><div><h3>What happens when you try to create a set with mutable elements like lists?</h3><div><div><div><p>Python won't let you create a set containing lists. Since sets need hashable elements to work efficiently, they can only store immutable types like numbers, strings, and tuples. Lists, being mutable, would cause problems if modified after being added to a set since their hash value would change.</p><p>To store lists in a set-like structure, you have two options:</p><ul><li>Convert lists to tuples using <code>tuple()</code></li><li>Use a different data structure like a list of lists</li></ul></div></div></div></div></div><h2>🏠</h2></body></html>