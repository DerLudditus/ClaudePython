<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title>How to repeat something in Python</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@700&amp;family=Literata:wght@400;700&amp;family=Fira+Code:wght@400;700&amp;display=swap" rel="stylesheet" type="text/css" />
  <link href="styles.css" rel="stylesheet" type="text/css" />
</head><body id="top">
  <script src="script.js"></script>
<h1><a href="index.html">How to repeat something in Python</a></h1><div><div><div><p>Python offers multiple ways to repeat code execution through loops and iteration. Whether you need to process data collections, implement recursive algorithms, or automate repetitive tasks, Python's repetition structures provide elegant solutions.</p><p>This guide covers essential repetition techniques, practical tips, and real-world applications, complete with code examples created with <a href="https://claude.ai/">Claude</a>, an AI assistant built by Anthropic. You'll learn debugging strategies to write efficient, reliable code.</p><h2>Using a simple <code>for</code> loop for repetition</h2><pre><code>for i in range(5):
    print(f&quot;This is repetition {i+1}&quot;)</code></pre><pre><code>This is repetition 1
This is repetition 2
This is repetition 3
This is repetition 4
This is repetition 5</code></pre><p>The <code>for</code> loop demonstrates Python's straightforward approach to repetition by leveraging the <code>range()</code> function. This combination creates a simple counter that executes the code block a specified number of times—in this case, five iterations.</p><p>The loop variable <code>i</code> serves two purposes in this example:</p><ul><li>Tracks the current iteration number automatically</li><li>Enables dynamic content creation through string formatting with <code>f-strings</code></li></ul><p>While this example uses basic print statements, the same pattern applies to more complex operations like data processing, file operations, or API calls where you need predictable repetition with a known number of iterations.</p><h2>Basic repetition techniques</h2><p>Beyond the basic <code>for</code> loop pattern, Python provides several powerful repetition tools including <code>while</code> loops, customizable <code>range()</code> parameters, and the multiplication operator for sequence repetition.</p><h3>Using <code>while</code> loops for conditional repetition</h3><pre><code>count = 0
while count &lt; 5:
    print(f&quot;Repeating with while: {count}&quot;)
    count += 1</code></pre><pre><code>Repeating with while: 0
Repeating with while: 1
Repeating with while: 2
Repeating with while: 3
Repeating with while: 4</code></pre><p>The <code>while</code> loop creates a flexible repetition structure that continues as long as a condition remains true. In this example, the loop runs while <code>count</code> stays below 5, printing the current value and incrementing it with each iteration.</p><ul><li>The counter initialization (<code>count = 0</code>) happens before the loop begins</li><li>The condition (<code>count &lt; 5</code>) checks at the start of each iteration</li><li>The increment (<code>count += 1</code>) prevents an infinite loop by moving toward the exit condition</li></ul><p>Unlike <code>for</code> loops which typically handle a predefined sequence, <code>while</code> loops excel when you need to repeat based on dynamic conditions that might change during execution. This makes them particularly useful for user input validation or processing data streams.</p><h3>Customizing <code>range()</code> for flexible repetition</h3><pre><code>for num in range(2, 11, 2):
    print(f&quot;Even number: {num}&quot;)</code></pre><pre><code>Even number: 2
Even number: 4
Even number: 6
Even number: 8
Even number: 10</code></pre><p>The <code>range()</code> function accepts three parameters to control iteration behavior: start value, stop value, and step size. In this example, <code>range(2, 11, 2)</code> generates a sequence starting at 2, stopping before 11, and incrementing by 2 each time.</p><ul><li>Start value (2) defines where the sequence begins</li><li>Stop value (11) sets the upper boundary. Python stops before reaching this number</li><li>Step size (2) determines the increment between numbers. Using 2 generates only even numbers</li></ul><p>This flexibility makes <code>range()</code> ideal for scenarios where you need precise control over sequence generation. The code efficiently prints even numbers from 2 to 10 without manual calculations or complex logic.</p><h3>Repeating sequences with the <code>*</code> operator</h3><pre><code>repeated_list = [1, 2, 3] * 3
print(repeated_list)

repeated_string = &quot;abc&quot; * 5
print(repeated_string)</code></pre><pre><code>[1, 2, 3, 1, 2, 3, 1, 2, 3]
abcabcabcabcabc</code></pre><p>Python's multiplication operator (<code>*</code>) provides a concise way to repeat sequences like lists and strings. When applied to a list, it creates a new list containing the original elements repeated the specified number of times. When used with strings, it concatenates multiple copies of that string.</p><ul><li>The expression <code>[1, 2, 3] * 3</code> creates a new list containing three copies of the original sequence. Each element maintains its original order</li><li>String multiplication with <code>"abc" * 5</code> generates a new string with five repetitions of the original characters</li></ul><p>This operator significantly reduces the code needed compared to traditional loops. It's particularly useful when you need quick sequence duplication for testing, data generation, or string formatting tasks.</p><h2>Advanced repetition techniques</h2><p>Building on Python's basic repetition tools, advanced techniques like <code>itertools</code>, list comprehensions, and recursion unlock powerful ways to write more elegant and efficient code.</p><h3>Efficient repetition with <code>itertools</code></h3><pre><code>import itertools

for item in itertools.repeat(&quot;Python&quot;, 4):
    print(item)

for item in itertools.islice(itertools.cycle([1, 2, 3]), 6):
    print(item, end=&quot; &quot;)</code></pre><pre><code>Python
Python
Python
Python
1 2 3 1 2 3</code></pre><p>The <code>itertools</code> module provides specialized tools for efficient iteration. The <code>repeat()</code> function creates an iterator that outputs the same value a specified number of times, while <code>cycle()</code> continuously loops through a sequence indefinitely.</p><ul><li><code>itertools.repeat("Python", 4)</code> generates "Python" exactly four times without storing the repeated values in memory</li><li><code>itertools.cycle([1, 2, 3])</code> creates an infinite loop of the sequence 1, 2, 3</li><li><code>itertools.islice()</code> limits the infinite cycle to a specific number of iterations. In this case, it takes the first 6 elements</li></ul><p>These functions excel at memory efficiency compared to traditional sequence multiplication. They're particularly valuable when working with large datasets or when you need precise control over iteration patterns.</p><h3>Repeated operations using list comprehensions</h3><pre><code>repeated = [num for num in range(1, 5) for _ in range(num)]
print(repeated)

modifications = [f&quot;Item-{i}&quot; for i in range(3) for _ in range(2)]
print(modifications)</code></pre><pre><code>[1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
[&#x27;Item-0&#x27;, &#x27;Item-0&#x27;, &#x27;Item-1&#x27;, &#x27;Item-1&#x27;, &#x27;Item-2&#x27;, &#x27;Item-2&#x27;]</code></pre><p>List comprehensions enable powerful nested repetition patterns in a single line of code. The first example creates a list where each number appears as many times as its value. For instance, 2 appears twice and 3 appears three times.</p><ul><li>The outer loop <code>num for num in range(1, 5)</code> generates numbers 1 through 4</li><li>The inner loop <code>for _ in range(num)</code> repeats each number based on its value</li><li>The underscore <code>_</code> indicates we don't need the inner loop's counter variable</li></ul><p>The second example demonstrates a simpler pattern that creates formatted strings with consistent repetition. Each <code>Item-{i}</code> appears exactly twice in the output list because the inner loop uses <code>range(2)</code>.</p><p>This approach offers a concise alternative to nested <code>for</code> loops when you need to generate repeated elements in lists. It's particularly useful for creating test data or formatting sequences with predictable patterns.</p><h3>Using recursion for controlled repetition</h3><pre><code>def repeat_action(times, current=0):
    if current &gt;= times:
        return
    print(f&quot;Recursion level: {current}&quot;)
    repeat_action(times, current + 1)

repeat_action(4)</code></pre><pre><code>Recursion level: 0
Recursion level: 1
Recursion level: 2
Recursion level: 3</code></pre><p>Recursion creates repetition by having a function call itself with updated parameters. The <code>repeat_action</code> function demonstrates this through two key components: a base case that stops recursion when <code>current</code> reaches <code>times</code>, and a recursive case that prints the current level before making another call.</p><ul><li>The <code>current</code> parameter tracks progress through each recursive call</li><li>Each function call creates a new stack frame, maintaining its own version of <code>current</code></li><li>The base case prevents infinite recursion by checking if <code>current >= times</code></li></ul><p>When called with <code>repeat_action(4)</code>, the function creates four levels of recursion. Each level prints its value before calling the next level. This creates a controlled sequence of repetitions that automatically unwinds once the base case triggers.</p><h3>Processing text data with <code>for</code> loops</h3><p>The <code>splitlines()</code> method combined with Python's <code>enumerate()</code> function enables efficient line-by-line text processing while automatically tracking line numbers for structured data analysis.</p><pre><code>sample_text = &quot;Python\nRepetition\nTechniques&quot;
for line_number, line in enumerate(sample_text.splitlines(), 1):
    print(f&quot;Line {line_number}: {line}&quot;)</code></pre><p>This code demonstrates a powerful combination of three Python features working together. The <code>splitlines()</code> method breaks the multi-line string into separate lines at each newline character (<code>\n</code>). The <code>enumerate()</code> function then creates pairs of numbers and lines, with the optional parameter <code>1</code> telling it to start counting from 1 instead of 0.</p><p>When executed, the code produces formatted output that displays each line prefixed with its line number. The <code>f-string</code> handles the string formatting elegantly by embedding the variables directly in the output template.</p><ul><li>Creates a clean, numbered list from multi-line text</li><li>Automatically handles line breaks and numbering</li><li>Uses modern Python string formatting for readable output</li></ul><h3>Simulating web scraping with repetition</h3><p>Python's repetition structures enable efficient web scraping by systematically collecting data from multiple pages while managing the complexity of network requests and data storage.</p><pre><code>pages = [f&quot;page{i}.html&quot; for i in range(1, 5)]
scraped_data = []

for page in pages:
    print(f&quot;Scraping {page}...&quot;)
    # Simulate extracting data from each page
    data = f&quot;Content from {page}&quot;
    scraped_data.append(data)

print(f&quot;Collected {len(scraped_data)} items:&quot;)
for item in scraped_data:
    print(item)</code></pre><p>This code demonstrates a practical approach to batch data collection using list comprehension and loops. The first line creates a list of HTML page names using an <code>f-string</code> inside a list comprehension. Each name follows the pattern <code>page1.html</code> through <code>page4.html</code>.</p><p>The main loop processes each page name sequentially. It prints a status message and simulates data extraction by creating a simple string. The extracted content gets stored in the <code>scraped_data</code> list using <code>append()</code>.</p><ul><li>Creates structured filenames dynamically</li><li>Tracks progress with status messages</li><li>Stores results in a central list</li></ul><p>The final section reports the total number of items collected and displays each piece of data. This pattern forms the foundation for real-world data collection tasks.</p><h2>Common errors and challenges</h2><p>Python's repetition structures can trigger subtle bugs that impact program behavior when developers overlook critical implementation details.</p><h3>Avoiding infinite loops in <code>while</code> statements</h3><p>Infinite loops occur when a <code>while</code> loop's condition never evaluates to <code>False</code>. The most common cause is forgetting to update the control variable that determines when the loop should end. The code below demonstrates this classic pitfall.</p><pre><code>counter = 0
while counter &lt; 5:
    print(f&quot;Current count: {counter}&quot;)</code></pre><p>The code lacks the crucial <code>counter += 1</code> increment statement inside the loop. This oversight prevents <code>counter</code> from ever reaching 5, trapping the program in endless repetition. Let's examine the corrected version below.</p><pre><code>counter = 0
while counter &lt; 5:
    print(f&quot;Current count: {counter}&quot;)
    counter += 1</code></pre><p>The corrected code adds <code>counter += 1</code> inside the loop, which increments the counter variable after each iteration. This ensures the loop eventually reaches its termination condition when <code>counter</code> equals 5.</p><ul><li>Always update control variables inside <code>while</code> loops</li><li>Place the update statement where it logically affects the loop condition</li><li>Consider using a <code>for</code> loop instead when working with a known number of iterations</li></ul><p>Watch for infinite loops in scenarios with complex conditions or multiple exit points. They commonly occur when processing user input or waiting for external events. A well-structured loop should always make progress toward its termination condition.</p><h3>Fixing off-by-one errors with <code>range()</code></h3><p>Off-by-one errors frequently occur when developers misunderstand how Python's <code>range()</code> function handles start and stop values. These subtle bugs can cause loops to process one too many or too few items. The code below demonstrates a common mistake where the sequence ends earlier than intended.</p><pre><code>for i in range(1, 5):
    print(f&quot;Number: {i}&quot;)</code></pre><p>The <code>range(1, 5)</code> function stops at 4 instead of 5 because Python excludes the stop value. This creates a sequence that doesn't match many real-world counting scenarios. The code below demonstrates the proper implementation.</p><pre><code>for i in range(1, 6):
    print(f&quot;Number: {i}&quot;)</code></pre><p>The corrected code uses <code>range(1, 6)</code> to generate numbers from 1 through 5, ensuring the sequence includes the intended final value. Python's <code>range()</code> function creates sequences that include the start value but exclude the stop value. This behavior often surprises developers who expect inclusive bounds.</p><ul><li>When counting items or creating sequences with specific start and end values, add 1 to the stop value</li><li>Pay special attention when working with array indices or mathematical sequences</li><li>Consider using explicit bounds checking for critical calculations</li></ul><p>This pattern appears frequently in data processing and numerical computations. Watch for it when porting algorithms from other languages that handle ranges differently.</p><h3>Safely modifying lists during iteration</h3><p>Modifying a list while iterating through it can lead to unexpected results and skipped elements. Python's iteration mechanism tracks list indices during the loop. When you remove items mid-iteration, the index tracking becomes misaligned with the modified list structure.</p><pre><code>numbers = [1, 2, 3, 4, 5]
for num in numbers:
    if num % 2 == 0:
        numbers.remove(num)
print(numbers)</code></pre><p>When the loop removes even numbers, it shifts remaining elements left. This causes the loop to skip checking some numbers since the iteration index keeps advancing. The code below demonstrates a safer approach to list modification during iteration.</p><pre><code>numbers = [1, 2, 3, 4, 5]
numbers_to_keep = [num for num in numbers if num % 2 != 0]
print(numbers_to_keep)</code></pre><p>The list comprehension approach creates a new list containing only the elements we want to keep. This avoids the pitfalls of modifying a list during iteration. The expression <code>[num for num in numbers if num % 2 != 0]</code> efficiently filters out even numbers while preserving the original list structure.</p><ul><li>Watch for this issue when filtering, removing, or modifying list elements based on conditions</li><li>Consider using list comprehensions or creating a new list for cleaner, more predictable results</li><li>Remember that modifying collection size during iteration can lead to skipped elements or incorrect processing</li></ul><p>This pattern appears frequently in data cleaning and filtering operations. The list comprehension solution provides better readability and reduces the chance of introducing subtle bugs.</p></div></div></div><h2>FAQs</h2><div><div><h3>How do you repeat a string multiple times in Python?</h3><div><div><div><p>Python's string multiplication operator <code>*</code> lets you repeat a string by multiplying it with an integer. For example, <code>"hello" * 3</code> produces <code>hellohellohello</code>. This works because Python treats strings as sequences of characters that can be duplicated through multiplication.</p><p>The <code>*</code> operator creates a new string by concatenating the original string with itself the specified number of times. This approach is more efficient than using loops since Python optimizes the operation internally.</p></div></div></div></div></div><div><div><h3>What&#x27;s the difference between using a &#x27;for&#x27; loop and a &#x27;while&#x27; loop for repetition?</h3><div><div><div><p>A <code>for</code> loop works best when you know exactly how many times you need to repeat something. It bundles the loop's setup, condition, and increment into a single line—making it cleaner and more predictable. A <code>while</code> loop shines when you need flexibility and can't predict the number of iterations upfront.</p><p>Consider these real-world applications:</p><ul><li>Use <code>for</code> to process a list of 100 customer orders</li><li>Use <code>while</code> to keep accepting user input until they type "quit"</li></ul></div></div></div></div></div><div><div><h3>Can you repeat a list or tuple using the multiplication operator?</h3><div><div><div><p>Yes, you can multiply lists and tuples by an integer in Python to create repeated copies. The <code>*</code> operator concatenates the sequence with itself the specified number of times, creating a new sequence containing repeated elements. For example, <code>[1, 2] * 3</code> produces <code>[1, 2, 1, 2, 1, 2]</code>.</p><p>This works because Python's sequence types implement multiplication as a form of repetition rather than mathematical multiplication. The operation creates a shallow copy, meaning it references the same objects in memory when dealing with nested sequences or mutable objects.</p></div></div></div></div></div><div><div><h3>How do you break out of an infinite loop in Python?</h3><div><div><div><p>Python's <code>break</code> statement immediately exits a loop, transferring control to the first line after the loop block. While loops often need an escape mechanism to prevent infinite execution. You can place <code>break</code> inside an <code>if</code> condition that checks for your exit criteria.</p><p>For more complex scenarios, consider these reliable approaches:</p><ul><li>Use <code>Ctrl+C</code> to trigger a keyboard interrupt during program execution</li><li>Set a counter variable to limit iterations</li><li>Define a specific exit condition based on your data or computation results</li></ul></div></div></div></div></div><div><div><h3>What happens when you use range() with different parameters for repetition?</h3><div><div><div><p>The <code>range()</code> function creates sequences of numbers based on its parameters. With one parameter like <code>range(5)</code>, it generates numbers from 0 to 4. Using two parameters <code>range(2, 5)</code> sets both start and end points, producing 2 through 4. Adding a third parameter <code>range(0, 10, 2)</code> determines the step size, generating every second number.</p><p>This flexibility makes <code>range()</code> ideal for controlling loops and creating numeric sequences. The function generates values efficiently by calculating numbers on demand rather than storing the entire sequence in memory.</p></div></div></div></div></div><h2>🏠</h2></body></html>