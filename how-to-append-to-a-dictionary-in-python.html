<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title>How to append to a dictionary in Python</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@700&amp;family=Literata:wght@400;700&amp;family=Fira+Code:wght@400;700&amp;display=swap" rel="stylesheet" type="text/css" />
  <link href="styles.css" rel="stylesheet" type="text/css" />
</head><body id="top">
  <script src="script.js"></script>
<h1><a href="index.html">How to append to a dictionary in Python</a></h1><div><div><div><p>Python dictionaries store key-value pairs that let you organize and access data efficiently. Adding new entries requires understanding the different methods available, from basic assignment with <code>=</code> to specialized dictionary methods.</p><p>This guide covers essential techniques for dictionary manipulation, with practical examples and troubleshooting tips created using <a href="https://claude.ai/">Claude</a>, an AI assistant built by Anthropic.</p><h2>Adding a key-value pair to a dictionary</h2><pre><code>student = {&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 21}
student[&quot;grade&quot;] = &quot;A&quot;
print(student)</code></pre><pre><code>{&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 21, &#x27;grade&#x27;: &#x27;A&#x27;}</code></pre><p>The square bracket syntax <code>student["grade"] = "A"</code> directly assigns a new key-value pair to the dictionary. This approach offers more flexibility than other methods since it works with any valid key type—not just strings.</p><p>Square bracket assignment provides these key advantages:</p><ul><li>Dynamically creates the key if it doesn't exist</li><li>Updates the value if the key already exists</li><li>Allows for variable keys and computed expressions</li></ul><p>This straightforward method remains the most common way to add dictionary entries in Python. It maintains readable code while giving you full control over key-value manipulation.</p><h2>Common dictionary update techniques</h2><p>Beyond basic square bracket assignment, Python offers powerful methods like <code>update()</code>, <code>**</code> unpacking, and dictionary comprehensions to efficiently combine and extend dictionaries.</p><h3>Using the <code>update()</code> method to add multiple items</h3><pre><code>car = {&quot;make&quot;: &quot;Toyota&quot;, &quot;model&quot;: &quot;Corolla&quot;}
car.update({&quot;year&quot;: 2022, &quot;color&quot;: &quot;blue&quot;})
print(car)</code></pre><pre><code>{&#x27;make&#x27;: &#x27;Toyota&#x27;, &#x27;model&#x27;: &#x27;Corolla&#x27;, &#x27;year&#x27;: 2022, &#x27;color&#x27;: &#x27;blue&#x27;}</code></pre><p>The <code>update()</code> method efficiently adds multiple key-value pairs to a dictionary in a single operation. Unlike individual assignments, you can pass an entire dictionary as an argument to merge its contents with the target dictionary.</p><ul><li>Updates existing keys with new values if there are conflicts</li><li>Preserves the original key-value pairs that don't overlap</li><li>Accepts various input formats including dictionaries, keyword arguments, and iterables of key-value pairs</li></ul><p>In the example, <code>car.update()</code> adds both the year and color simultaneously to the original dictionary containing make and model. This approach streamlines code when you need to incorporate multiple related values at once.</p><h3>Using dictionary unpacking with <code>**</code> operator</h3><pre><code>fruits = {&quot;apple&quot;: 5, &quot;banana&quot;: 3}
more_fruits = {&quot;orange&quot;: 2, &quot;grape&quot;: 4}
all_fruits = {**fruits, **more_fruits}
print(all_fruits)</code></pre><pre><code>{&#x27;apple&#x27;: 5, &#x27;banana&#x27;: 3, &#x27;orange&#x27;: 2, &#x27;grape&#x27;: 4}</code></pre><p>The double asterisk operator <code>**</code> merges multiple dictionaries into a new one. This unpacking syntax creates a clean, readable way to combine dictionaries without modifying the originals.</p><ul><li>The expression <code>{**fruits, **more_fruits}</code> creates a new dictionary by unpacking both source dictionaries</li><li>Python processes the unpacking from left to right. If duplicate keys exist, the rightmost value wins</li><li>The operation preserves the original dictionaries <code>fruits</code> and <code>more_fruits</code> unchanged</li></ul><p>Dictionary unpacking offers a more elegant alternative to <code>update()</code> when you need to merge dictionaries without side effects. This approach particularly shines when combining three or more dictionaries in a single expression.</p><h3>Merging dictionaries with dictionary comprehensions</h3><pre><code>dict1 = {&quot;a&quot;: 1, &quot;b&quot;: 2}
dict2 = {&quot;b&quot;: 3, &quot;c&quot;: 4}
merged = {k: dict2.get(k, dict1.get(k)) for k in set(dict1) | set(dict2)}
print(merged)</code></pre><pre><code>{&#x27;a&#x27;: 1, &#x27;b&#x27;: 3, &#x27;c&#x27;: 4}</code></pre><p>Dictionary comprehensions provide a concise way to merge dictionaries while controlling how overlapping keys combine. The expression <code>set(dict1) | set(dict2)</code> creates a union of all unique keys from both dictionaries.</p><ul><li>The <code>get()</code> method safely retrieves values with a fallback option if the key isn't found</li><li>When processing each key, the code first checks <code>dict2</code>. If the key isn't there, it falls back to <code>dict1</code></li><li>This approach gives <code>dict2</code> priority for duplicate keys. In the example, <code>b</code> takes the value 3 from <code>dict2</code> instead of 2 from <code>dict1</code></li></ul><p>This method offers more control over value selection compared to dictionary unpacking. You can easily modify the comprehension logic to implement custom merging rules based on your needs.</p><h2>Advanced dictionary techniques</h2><p>Python's specialized dictionary tools like <code>defaultdict</code>, <code>setdefault()</code>, and <code>ChainMap</code> unlock powerful ways to handle nested data structures and manage dictionary hierarchies with minimal code.</p><h3>Using <code>collections.defaultdict</code> for nested dictionaries</h3><pre><code>from collections import defaultdict
user_scores = defaultdict(dict)
user_scores[&quot;Alice&quot;][&quot;math&quot;] = 95
user_scores[&quot;Alice&quot;][&quot;science&quot;] = 92
print(dict(user_scores))</code></pre><pre><code>{&#x27;Alice&#x27;: {&#x27;math&#x27;: 95, &#x27;science&#x27;: 92}}</code></pre><p><code>defaultdict</code> automatically creates a new dictionary when you access a non-existent key. This eliminates the need to manually check and initialize nested dictionaries, making your code cleaner and more efficient.</p><ul><li>The argument passed to <code>defaultdict(dict)</code> specifies the default factory function that creates the nested dictionary structure</li><li>When you access <code>user_scores["Alice"]</code> for the first time, it automatically creates an empty dictionary instead of raising a <code>KeyError</code></li><li>This behavior enables direct nested assignments like <code>user_scores["Alice"]["math"] = 95</code> without additional setup code</li></ul><p>Regular dictionaries would require explicit initialization of the nested structure before assignment. <code>defaultdict</code> handles this automatically, reducing boilerplate code and potential errors in your data structure management.</p><h3>Using <code>setdefault()</code> to append with a default value</h3><pre><code>contacts = {&quot;John&quot;: [&quot;555-1234&quot;]}
contacts.setdefault(&quot;John&quot;, []).append(&quot;555-5678&quot;)
contacts.setdefault(&quot;Mary&quot;, []).append(&quot;555-9012&quot;)
print(contacts)</code></pre><pre><code>{&#x27;John&#x27;: [&#x27;555-1234&#x27;, &#x27;555-5678&#x27;], &#x27;Mary&#x27;: [&#x27;555-9012&#x27;]}</code></pre><p>The <code>setdefault()</code> method provides a clean way to handle dictionary values that need default initialization. It returns the value for a given key if it exists. If the key doesn't exist, it creates the key with the specified default value and returns that value.</p><ul><li>When adding a second phone number for John, <code>setdefault()</code> returns the existing list <code>["555-1234"]</code>. The <code>append()</code> then adds the new number to this list</li><li>For Mary's entry, <code>setdefault()</code> first creates a new empty list since the key doesn't exist. Then <code>append()</code> adds the phone number to this new list</li></ul><p>This approach eliminates the need for explicit key existence checks and separate initialization steps. You can safely append values without worrying whether the key already exists in the dictionary.</p><h3>Using <code>ChainMap</code> for dictionary views</h3><pre><code>from collections import ChainMap
defaults = {&quot;theme&quot;: &quot;dark&quot;, &quot;language&quot;: &quot;en&quot;}
user_settings = {&quot;theme&quot;: &quot;light&quot;}
settings = ChainMap(user_settings, defaults)
print(dict(settings))</code></pre><pre><code>{&#x27;theme&#x27;: &#x27;light&#x27;, &#x27;language&#x27;: &#x27;en&#x27;}</code></pre><p><code>ChainMap</code> creates a view of multiple dictionaries in a specified priority order. When you look up a key, it searches through the dictionaries in sequence until it finds a match. This makes it perfect for implementing layered configurations like settings with defaults.</p><ul><li>The first dictionary (<code>user_settings</code>) takes precedence. Any matching keys here override values from later dictionaries</li><li>If a key isn't found in the first dictionary, <code>ChainMap</code> checks subsequent dictionaries in order</li><li>The original dictionaries remain unchanged. <code>ChainMap</code> simply provides a unified view</li></ul><p>In the example, <code>theme</code> comes from <code>user_settings</code> while <code>language</code> falls back to the value in <code>defaults</code>. This creates an elegant solution for managing configuration hierarchies without complex conditional logic.</p><h3>Text analysis with a <code>dict</code> frequency counter</h3><p>Dictionaries excel at tracking word frequencies in text analysis by using the <code>get()</code> method to safely increment counters without explicit initialization checks.</p><pre><code>text = &quot;to be or not to be that is the question&quot;
word_freq = {}
for word in text.split():
    word_freq[word] = word_freq.get(word, 0) + 1
print(word_freq)</code></pre><p>This code creates a dictionary that counts how many times each word appears in a text string. The <code>split()</code> method breaks the string into individual words. For each word, the code uses <code>get()</code> to either retrieve its current count or return 0 if the word isn't in the dictionary yet.</p><ul><li>The <code>get()</code> method's second parameter (0) serves as a default value</li><li>Adding 1 to this value updates the count for each word occurrence</li><li>The <code>word_freq[word] = </code> assignment stores the new count back in the dictionary</li></ul><p>This pattern efficiently handles both new and existing words in a single line. The final dictionary will show each unique word as a key with its frequency as the value.</p><h3>Creating a memoization cache with <code>dict</code> for recursive functions</h3><p>Dictionaries serve as powerful caching tools to speed up recursive functions by storing previously calculated results—a technique called memoization that prevents redundant computations.</p><pre><code>cache = {}
def fibonacci(n):
    if n in cache:
        return cache[n]
    if n &lt;= 1:
        result = n
    else:
        result = fibonacci(n-1) + fibonacci(n-2)
    cache[n] = result
    return result

print(fibonacci(6))
print(&quot;Cache:&quot;, cache)</code></pre><p>This implementation of the <code>fibonacci()</code> function uses a dictionary called <code>cache</code> to store previously calculated Fibonacci numbers. When calculating <code>fibonacci(6)</code>, the function first checks if the result exists in the cache. If not found, it recursively calculates the value using the standard Fibonacci formula.</p><ul><li>The <code>if n in cache</code> check prevents redundant calculations by returning cached results immediately</li><li>Each new calculation gets stored in the cache with <code>cache[n] = result</code></li><li>Base cases (<code>n &lt;= 1</code>) return <code>n</code> directly</li></ul><p>This caching strategy dramatically improves performance by avoiding repeated computations of the same Fibonacci numbers during recursion. Each number only needs to be calculated once.</p><h2>Common errors and challenges</h2><p>Python dictionaries can trigger subtle errors when modifying data structures, from missing keys to iteration conflicts and nested data complexities.</p><h3>Avoiding <code>KeyError</code> when accessing non-existent keys</h3><p>Accessing dictionary keys that don't exist triggers Python's <code>KeyError</code> exception. This common pitfall occurs when developers directly reference keys without first verifying their presence in the dictionary. The code below demonstrates how attempting to access a non-existent <code>phone</code> key leads to a runtime error.</p><pre><code>user_data = {&quot;name&quot;: &quot;Alice&quot;, &quot;email&quot;: &quot;alice@example.com&quot;}
phone = user_data[&quot;phone&quot;]  # This raises KeyError: &#x27;phone&#x27;
print(f&quot;Phone number: {phone}&quot;)</code></pre><p>The code attempts to directly access the <code>phone</code> key without first checking if it exists in <code>user_data</code>. Python immediately halts execution when it can't find the requested key. Let's examine a safer approach in the next example.</p><pre><code>user_data = {&quot;name&quot;: &quot;Alice&quot;, &quot;email&quot;: &quot;alice@example.com&quot;}
phone = user_data.get(&quot;phone&quot;, &quot;Not available&quot;)
print(f&quot;Phone number: {phone}&quot;)</code></pre><p>The <code>get()</code> method provides a safer way to access dictionary values by accepting a default fallback value. When Python can't find the requested key, it returns this default instead of raising an error. This approach maintains smooth code execution while handling missing data gracefully.</p><ul><li>Watch for direct key access with square brackets in code that processes user input or external data</li><li>Consider using <code>get()</code> whenever a key's existence is uncertain</li><li>Choose meaningful default values that help debug issues or provide useful feedback</li></ul><p>The example demonstrates this by returning "Not available" when the phone number doesn't exist. This pattern proves especially valuable when processing data from APIs or user forms where missing fields are common.</p><h3>Preventing dictionary modification errors during iteration</h3><p>Modifying a Python dictionary while iterating through it can trigger runtime errors or produce unexpected results. The code below demonstrates a common mistake where adding new key-value pairs during a <code>for</code> loop creates unpredictable behavior.</p><pre><code>scores = {&quot;math&quot;: 90, &quot;science&quot;: 95, &quot;history&quot;: 85}
for subject in scores:
    if scores[subject] &gt; 90:
        scores[&quot;honors_&quot; + subject] = True  # Modifies dict during iteration
print(scores)</code></pre><p>Python's dictionary size changes when the loop adds new <code>honors_</code> entries. This disrupts the iterator's internal tracking of dictionary elements. The following code demonstrates a safer approach to handle this scenario.</p><pre><code>scores = {&quot;math&quot;: 90, &quot;science&quot;: 95, &quot;history&quot;: 85}
honors_subjects = {}
for subject in scores:
    if scores[subject] &gt; 90:
        honors_subjects[&quot;honors_&quot; + subject] = True
scores.update(honors_subjects)  # Updates after iteration completes
print(scores)</code></pre><p>The solution creates a temporary dictionary <code>honors_subjects</code> to store new entries while iterating through the original <code>scores</code> dictionary. This approach prevents runtime errors by separating the iteration and modification steps.</p><ul><li>Store new key-value pairs in a separate dictionary during iteration</li><li>Use <code>update()</code> to merge changes after the loop completes</li><li>Watch for this pattern when your code needs to add or modify dictionary entries based on existing values</li></ul><p>This error commonly occurs in data processing tasks where you need to derive new values from existing dictionary entries. Always consider creating a separate dictionary for new entries when your loop logic involves dictionary modifications.</p><h3>Understanding nested dictionary copying issues</h3><p>Python's standard dictionary copying methods can produce unexpected behavior with nested data structures. The <code>copy()</code> method creates a shallow copy that still references nested objects in memory. This leads to unintended modifications when working with nested dictionaries or lists. Let's examine this behavior in the code below.</p><pre><code>import copy
original = {&quot;user&quot;: {&quot;name&quot;: &quot;John&quot;, &quot;scores&quot;: [85, 90]}}
copied = original.copy()  # Creates shallow copy
copied[&quot;user&quot;][&quot;scores&quot;][0] = 100  # Modifies original too!
print(original[&quot;user&quot;][&quot;scores&quot;])  # Shows [100, 90]</code></pre><p>The shallow copy creates a new dictionary that still points to the same nested objects in memory. When you modify nested data in the copied version, those changes affect both dictionaries since they share references. The next code example demonstrates the proper solution.</p><pre><code>import copy
original = {&quot;user&quot;: {&quot;name&quot;: &quot;John&quot;, &quot;scores&quot;: [85, 90]}}
copied = copy.deepcopy(original)  # Creates deep copy
copied[&quot;user&quot;][&quot;scores&quot;][0] = 100  # Only affects the copy
print(original[&quot;user&quot;][&quot;scores&quot;])  # Still shows [85, 90]</code></pre><p>The <code>copy.deepcopy()</code> function creates a completely independent copy of nested dictionaries by recursively duplicating all nested objects. This prevents unintended modifications to the original data structure when you change values in the copy.</p><ul><li>Watch for this issue when working with dictionaries containing lists, other dictionaries, or complex objects as values</li><li>Regular dictionary methods like <code>dict.copy()</code> or the <code>{}</code> operator only create shallow copies that share references to nested objects</li><li>Use <code>deepcopy()</code> when you need to modify nested data without affecting the source dictionary</li></ul><p>This pattern commonly appears in data processing pipelines where you need to transform nested structures while preserving the original data for later use or comparison.</p></div></div></div><h2>FAQs</h2><div><div><h3>What happens if I use append() on a dictionary instead of proper dictionary methods?</h3><div><div><div><p>The <code>append()</code> method doesn't work with dictionaries. Python will raise an <code>AttributeError</code> because dictionaries store key-value pairs rather than sequential items. Instead, you'll need proper dictionary methods like <code>update()</code> to add new entries or direct key assignment using square bracket notation.</p><p>To modify dictionaries correctly, use either <code>my_dict[new_key] = new_value</code> for single items or <code>my_dict.update()</code> to merge multiple key-value pairs at once. These approaches maintain the dictionary's fundamental structure while ensuring data integrity.</p></div></div></div></div></div><div><div><h3>How do I add a key-value pair to an existing dictionary using square bracket notation?</h3><div><div><div><p>Square bracket notation lets you add new key-value pairs to a dictionary by treating the key as an index. Simply write <code>dictionary[new_key] = value</code>. Python will create the key if it doesn't exist or update the existing value if it does.</p><p>This approach works because dictionaries are mutable data structures that store items as key-value mappings. The square brackets tell Python to access or create an entry at the specified key location.</p></div></div></div></div></div><div><div><h3>Can I use the update() method to add multiple items to a dictionary at once?</h3><div><div><div><p>Yes, Python's <code>update()</code> method efficiently adds multiple key-value pairs to a dictionary in a single operation. The method accepts another dictionary or an iterable of key-value pairs as input, merging them into the target dictionary.</p><ul><li>It modifies the original dictionary directly instead of creating a new one. This makes it more memory-efficient for large datasets.</li><li>When duplicate keys exist, <code>update()</code> overwrites the original values with new ones. This behavior ensures data consistency while combining dictionaries.</li></ul></div></div></div></div></div><div><div><h3>What&#x27;s the difference between using dictionary[&#x27;key&#x27;] = value versus setdefault() when adding items?</h3><div><div><div><p>The <code>dictionary['key'] = value</code> syntax directly assigns or overwrites a value, while <code>setdefault()</code> only sets the value if the key doesn't already exist. <code>setdefault()</code> returns the existing value if the key is present. This makes it particularly useful when initializing default values in data processing workflows.</p><p>Consider tracking user preferences: <code>setdefault()</code> preserves existing settings while adding new ones. The direct assignment approach would override user customizations.</p></div></div></div></div></div><div><div><h3>Is it possible to merge two dictionaries together using the &#x27;or&#x27; operator in modern Python versions?</h3><div><div><div><p>The <code>|</code> (or) operator can merge Python dictionaries since version 3.9. This union operator combines two dictionaries into a new one, with values from the right dictionary taking precedence in case of duplicate keys. Python introduced this feature to make dictionary operations more intuitive and consistent with set operations.</p><p>Here's what happens under the hood: Python creates a new dictionary, copies all key-value pairs from the left operand, then updates it with pairs from the right operand. This provides a clean, readable alternative to using <code>.update()</code> or dictionary comprehension.</p></div></div></div></div></div><h2>🏠</h2></body></html>