<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title>How to read an Excel file in Python</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@700&amp;family=Literata:wght@400;700&amp;family=Fira+Code:wght@400;700&amp;display=swap" rel="stylesheet" type="text/css" />
  <link href="styles.css" rel="stylesheet" type="text/css" />
</head><body id="top">
  <script src="script.js"></script>
<h1><a href="index.html">How to read an Excel file in Python</a></h1><div><div><div><p>Reading Excel files in Python enables you to efficiently process spreadsheet data for analysis and automation. Python's libraries provide powerful tools to extract, manipulate, and transform Excel data into formats your applications can use.</p><p>This guide covers essential techniques for Excel file handling in Python, with practical examples created using <a href="https://claude.ai/">Claude</a>, an AI assistant built by Anthropic. You'll learn implementation strategies and troubleshooting approaches.</p><h2>Using <code>pandas</code> to read Excel files</h2><pre><code>import pandas as pd

df = pd.read_excel(&#x27;data.xlsx&#x27;)
print(df.head())</code></pre><pre><code>ID   Name  Age      City
0   1  Alice   25  New York
1   2    Bob   30    Boston
2   3  Carol   22   Chicago
3   4  David   35   Seattle
4   5    Eve   28    Denver</code></pre><p>The <code>pandas</code> library simplifies Excel data handling through its powerful <code>read_excel()</code> function. This function automatically converts your spreadsheet into a DataFrame—a table-like structure that makes data manipulation more intuitive in Python.</p><p>The code demonstrates three key capabilities that make <code>pandas</code> particularly effective:</p><ul><li>Automatic column detection and naming from the Excel headers</li><li>Native support for various Excel file formats (.xlsx, .xls, .xlsm)</li><li>Built-in data preview using <code>head()</code> to verify the import worked correctly</li></ul><p>The resulting DataFrame preserves both the structure and data types from your Excel file. This means numbers stay as numbers and text remains as text, eliminating common data type conversion headaches.</p><h2>Basic Excel reading techniques</h2><p>Building on <code>pandas</code> fundamentals, Python offers granular control over Excel data through sheet selection, row filtering, and the powerful <code>openpyxl</code> library for advanced spreadsheet operations.</p><h3>Reading specific sheets with <code>pd.read_excel()</code></h3><pre><code>import pandas as pd

# Read a specific sheet by name
df1 = pd.read_excel(&#x27;data.xlsx&#x27;, sheet_name=&#x27;Sheet2&#x27;)
# Read a specific sheet by index (0-based)
df2 = pd.read_excel(&#x27;data.xlsx&#x27;, sheet_name=1)
print(f&quot;Sheet names: {pd.ExcelFile(&#x27;data.xlsx&#x27;).sheet_names}&quot;)</code></pre><pre><code>Sheet names: [&#x27;Sheet1&#x27;, &#x27;Sheet2&#x27;, &#x27;Sheet3&#x27;]</code></pre><p>The <code>sheet_name</code> parameter in <code>pd.read_excel()</code> gives you precise control over which Excel sheets to import. You can reference sheets either by their name (like <code>'Sheet2'</code>) or by their zero-based index position.</p><ul><li>Sheet names work reliably when you know the exact worksheet title</li><li>Index numbers (starting from 0) help when working with unknown sheet names</li><li>Use <code>pd.ExcelFile().sheet_names</code> to get a list of all available sheets in your workbook</li></ul><p>This flexibility proves especially valuable when processing Excel files with multiple worksheets. You can selectively import only the data you need instead of loading the entire workbook.</p><h3>Reading specific rows and columns</h3><pre><code>import pandas as pd

# Read specific rows
df = pd.read_excel(&#x27;data.xlsx&#x27;, skiprows=2, nrows=3)
# Read specific columns
df_cols = pd.read_excel(&#x27;data.xlsx&#x27;, usecols=&quot;A,C:E&quot;)
print(df_cols.head(2))</code></pre><pre><code>ID  Age      City
0   1   25  New York
1   2   30    Boston</code></pre><p>The <code>pd.read_excel()</code> function gives you precise control over which rows and columns to import from your Excel file. The <code>skiprows</code> parameter skips the specified number of rows from the top, while <code>nrows</code> determines how many rows to read after that point.</p><ul><li>Use <code>usecols</code> to select specific columns. The parameter accepts Excel-style references like <code>"A,C:E"</code> to pick individual columns (A) or ranges (C through E)</li><li>Combine these parameters to extract exactly the data subset you need without loading the entire spreadsheet</li><li>This targeted approach improves memory efficiency when working with large Excel files</li></ul><p>These parameters work together seamlessly. For example, you could skip the header row, read the next 100 rows, and select only the numerical columns—all in a single function call.</p><h3>Using <code>openpyxl</code> for Excel operations</h3><pre><code>from openpyxl import load_workbook

workbook = load_workbook(filename=&#x27;data.xlsx&#x27;)
sheet = workbook.active
value = sheet.cell(row=1, column=2).value
print(f&quot;Cell B1 contains: {value}&quot;)</code></pre><pre><code>Cell B1 contains: Name</code></pre><p>The <code>openpyxl</code> library provides direct, cell-level access to Excel files. Unlike pandas, which loads entire datasets, <code>openpyxl</code> lets you work with individual cells and worksheets for more granular control.</p><ul><li>The <code>load_workbook()</code> function opens your Excel file and creates a workbook object that represents the entire file</li><li>Access the currently selected worksheet using <code>workbook.active</code></li><li>Read specific cell values with <code>sheet.cell(row, column).value</code> using 1-based indexing. For example, cell B1 is row=1, column=2</li></ul><p>This approach works particularly well when you need to read or modify specific cells without loading the entire spreadsheet into memory. It's especially useful for large Excel files or when you need to maintain precise formatting.</p><h2>Advanced Excel reading methods</h2><p>Building on the foundational Excel reading techniques, Python offers sophisticated data handling capabilities through advanced <code>pandas</code> configurations, formula processing, and multiple engine support for complex spreadsheet operations.</p><h3>Using advanced <code>pandas</code> options</h3><pre><code>import pandas as pd

df = pd.read_excel(
    &#x27;data.xlsx&#x27;,
    dtype={&#x27;ID&#x27;: int, &#x27;Age&#x27;: int, &#x27;Name&#x27;: str},
    converters={&#x27;City&#x27;: lambda x: x.strip().upper()}
)
print(df[[&#x27;Name&#x27;, &#x27;City&#x27;]].head(2))</code></pre><pre><code>Name      City
0  Alice  NEW YORK
1    Bob    BOSTON</code></pre><p>The <code>pd.read_excel()</code> function offers powerful data type control through its <code>dtype</code> and <code>converters</code> parameters. These options ensure your data imports exactly as intended without manual cleanup later.</p><ul><li>The <code>dtype</code> parameter enforces specific data types for columns. In this example, it ensures <code>ID</code> and <code>Age</code> remain integers while <code>Name</code> stays as text</li><li>Use <code>converters</code> to transform data during import. Here, the City values get stripped of extra spaces and converted to uppercase through a lambda function</li><li>The <code>head(2)</code> method displays the first two rows of selected columns to verify the transformations worked correctly</li></ul><p>These configurations save time by handling data cleaning and formatting automatically during the import process instead of requiring separate steps afterward.</p><h3>Working with Excel formulas</h3><pre><code>import pandas as pd
from openpyxl import load_workbook

wb = load_workbook(&#x27;data.xlsx&#x27;, data_only=False)
ws = wb.active
formula = ws[&#x27;F1&#x27;].value
result = pd.read_excel(&#x27;data.xlsx&#x27;).iloc[0, 5]
print(f&quot;Formula: {formula}, Result: {result}&quot;)</code></pre><pre><code>Formula: =SUM(C1:E1), Result: 55</code></pre><p>Python offers two distinct approaches to handle Excel formulas. The <code>openpyxl</code> library with <code>data_only=False</code> reveals the actual formula text, while <code>pandas</code> shows the calculated results.</p><ul><li>Setting <code>data_only=False</code> in <code>load_workbook()</code> preserves formula expressions instead of their computed values</li><li>The <code>ws['F1'].value</code> syntax directly accesses cell contents, including formula text</li><li><code>pd.read_excel()</code> paired with <code>iloc</code> retrieves the formula's calculated result</li></ul><p>This dual capability proves valuable when auditing spreadsheet logic or debugging calculation issues. You can verify both the formula structure and its output in a single Python script.</p><h3>Reading Excel files with multiple engines</h3><pre><code>import pandas as pd

# Using xlrd engine (legacy Excel files .xls)
df_xls = pd.read_excel(&#x27;legacy.xls&#x27;, engine=&#x27;xlrd&#x27;)
# Using openpyxl engine (default for .xlsx)
df_xlsx = pd.read_excel(&#x27;data.xlsx&#x27;, engine=&#x27;openpyxl&#x27;)
print(&quot;Excel files loaded successfully with appropriate engines&quot;)</code></pre><pre><code>Excel files loaded successfully with appropriate engines</code></pre><p>Python's <code>pandas</code> library adapts to different Excel file formats by using specialized engines. The <code>engine</code> parameter in <code>read_excel()</code> determines how pandas processes your Excel files.</p><ul><li>The <code>xlrd</code> engine handles older .xls files that many organizations still use for legacy data</li><li>Modern Excel files (.xlsx) work best with the <code>openpyxl</code> engine which pandas uses by default</li><li>Specifying the correct engine prevents compatibility errors when working with different Excel versions</li></ul><p>This flexibility means you can work with both legacy and modern Excel files in the same Python script. Pandas automatically manages the complexity of different Excel formats while maintaining consistent DataFrame output for your analysis.</p><h3>Consolidating monthly reports from multiple Excel files</h3><p>Python's <code>pandas</code> library efficiently combines multiple Excel reports into a unified dataset, enabling quick analysis of data spread across separate monthly spreadsheets.</p><pre><code>import pandas as pd
import glob

# Get all Excel files and combine them
excel_files = glob.glob(&#x27;monthly_reports/*.xlsx&#x27;)
all_data = [pd.read_excel(file).assign(Source=file.split(&#x27;/&#x27;)[-1]) for file in excel_files[:3]]
combined_df = pd.concat(all_data, ignore_index=True)

print(f&quot;Combined data shape: {combined_df.shape}&quot;)
print(combined_df[[&#x27;Source&#x27;, &#x27;Revenue&#x27;]].groupby(&#x27;Source&#x27;).sum())</code></pre><p>This code efficiently processes multiple Excel files in a directory. The <code>glob</code> module finds all Excel files matching the pattern <code>monthly_reports/*.xlsx</code>. A list comprehension then reads each file into a pandas DataFrame while adding a Source column containing the filename.</p><ul><li>The <code>assign()</code> method adds the Source column during DataFrame creation</li><li>The <code>split('/')</code> and indexing <code>[-1]</code> extracts just the filename from the full path</li><li><code>pd.concat()</code> merges all DataFrames into one, with <code>ignore_index=True</code> creating fresh row indices</li></ul><p>The final lines display the combined DataFrame's dimensions and calculate revenue sums grouped by source file. The <code>[:3]</code> slice limits processing to the first three files for demonstration purposes.</p><h3>Analyzing financial data with <code>groupby</code> and <code>apply</code></h3><p>Python's <code>groupby</code> and <code>apply</code> functions transform raw financial spreadsheet data into meaningful business insights through aggregation and custom calculations.</p><pre><code>import pandas as pd

# Read financial data and calculate profit metrics by department
financial_data = pd.read_excel(&#x27;financial_records.xlsx&#x27;)
dept_summary = financial_data.groupby(&#x27;Department&#x27;).agg({
    &#x27;Revenue&#x27;: &#x27;sum&#x27;, &#x27;Expenses&#x27;: &#x27;sum&#x27;
})
dept_summary[&#x27;Profit_Margin&#x27;] = (dept_summary[&#x27;Revenue&#x27;] - dept_summary[&#x27;Expenses&#x27;]) / dept_summary[&#x27;Revenue&#x27;] * 100

print(dept_summary.sort_values(&#x27;Profit_Margin&#x27;, ascending=False).head(3))</code></pre><p>This code processes financial data from an Excel file to analyze departmental performance. The <code>groupby('Department')</code> function segments the data by department while <code>agg()</code> calculates the total revenue and expenses for each group.</p><ul><li>The code creates a new column called <code>Profit_Margin</code> using a standard financial formula: (Revenue - Expenses) / Revenue * 100</li><li>Finally, <code>sort_values()</code> orders departments by their profit margins in descending order</li><li>The <code>head(3)</code> function displays only the top 3 most profitable departments</li></ul><p>This analysis helps identify which departments generate the highest profit margins relative to their revenue. The approach efficiently transforms raw financial data into actionable business metrics.</p><h2>Common errors and challenges</h2><p>Python's Excel reading capabilities can trigger unexpected data type issues, missing value errors, and date parsing challenges that require specific configuration to resolve.</p><h3>Fixing numeric data read as strings with <code>dtype</code></h3><p>Excel files can store numbers in formats that <code>pandas</code> misinterprets as text strings. When this happens, numerical operations like <code>sum()</code> fail because Python can't perform math on text values. The code below demonstrates this common issue.</p><pre><code>import pandas as pd

# Numbers might be read as strings
df = pd.read_excel(&#x27;financial_data.xlsx&#x27;)
print(df[&#x27;Revenue&#x27;].dtype)
# This fails because Revenue is a string
result = df[&#x27;Revenue&#x27;].sum()
print(f&quot;Total revenue: {result}&quot;)</code></pre><p>When Excel stores numbers with special formatting or currency symbols, <code>pandas</code> defaults to importing them as text strings. This prevents mathematical operations from working correctly. The following code demonstrates the proper solution.</p><pre><code>import pandas as pd

# Explicitly set data types
df = pd.read_excel(&#x27;financial_data.xlsx&#x27;, dtype={&#x27;Revenue&#x27;: float})
print(df[&#x27;Revenue&#x27;].dtype)
result = df[&#x27;Revenue&#x27;].sum()
print(f&quot;Total revenue: {result}&quot;)</code></pre><p>The <code>dtype</code> parameter in <code>pd.read_excel()</code> forces numeric columns to import as their correct data type. By explicitly setting <code>Revenue</code> as <code>float</code>, you ensure pandas treats the values as numbers instead of strings.</p><ul><li>Watch for this issue when your Excel files contain currency symbols, percentage signs, or special number formatting</li><li>The error often surfaces when mathematical operations unexpectedly return incorrect results or raise type errors</li><li>Setting the correct data type during import is more efficient than converting types after loading the data</li></ul><h3>Dealing with <code>NaN</code> values in Excel imports</h3><p>Empty cells in Excel files create <code>NaN</code> (Not a Number) values when imported into pandas DataFrames. These missing values can break numerical calculations and statistical operations. The code below demonstrates how <code>NaN</code> values affect basic operations like calculating averages.</p><pre><code>import pandas as pd

# Empty cells become NaN by default
df = pd.read_excel(&#x27;customer_data.xlsx&#x27;)
# This raises error if Age column contains non-numeric values
average_age = df[&#x27;Age&#x27;].mean()
print(f&quot;Average age: {average_age}&quot;)</code></pre><p>When <code>NaN</code> values mix with valid numbers in the <code>Age</code> column, the <code>mean()</code> calculation fails. The DataFrame needs proper handling of these missing values to calculate accurate statistics. The following code demonstrates an effective solution.</p><pre><code>import pandas as pd

# Handle missing values during import
df = pd.read_excel(&#x27;customer_data.xlsx&#x27;, na_values=[&#x27;N/A&#x27;, &#x27;&#x27;], keep_default_na=True)
# Use dropna or fillna to handle NaN values
average_age = df[&#x27;Age&#x27;].fillna(0).mean()
print(f&quot;Average age: {average_age}&quot;)</code></pre><p>The <code>na_values</code> parameter tells pandas which values to treat as missing data, while <code>keep_default_na=True</code> preserves pandas' built-in list of NA indicators. This combination catches both explicit markers like 'N/A' and implicit ones like empty cells.</p><ul><li>Use <code>fillna(0)</code> to replace missing values with zeros before calculating statistics</li><li>Watch for this issue when your Excel files contain blank cells, 'N/A' entries, or other non-standard missing value indicators</li><li>Missing values often appear in real-world datasets from data entry errors or incomplete records</li></ul><p>The solution ensures your calculations work correctly by explicitly handling these gaps in your data instead of letting them cause errors.</p><h3>Resolving date parsing issues with <code>parse_dates</code></h3><p>Excel date formats often confuse pandas during import, causing the <code>read_excel()</code> function to misinterpret date columns as integers or strings. This prevents standard date operations and time-based analysis from working correctly. The code below demonstrates this common challenge.</p><pre><code>import pandas as pd

# Excel dates might be read incorrectly
df = pd.read_excel(&#x27;dates.xlsx&#x27;)
print(df[&#x27;Date&#x27;].dtype)
# Attempting date operations can fail
next_day = df.loc[0, &#x27;Date&#x27;] + pd.Timedelta(days=1)</code></pre><p>Without specifying the <code>parse_dates</code> parameter, pandas reads dates as generic objects that lack datetime functionality. This prevents date arithmetic and time-based analysis from working properly. Let's examine the corrected implementation below.</p><pre><code>import pandas as pd

# Explicitly parse date columns
df = pd.read_excel(&#x27;dates.xlsx&#x27;, parse_dates=[&#x27;Date&#x27;])
print(df[&#x27;Date&#x27;].dtype)
# Now date operations work correctly
next_day = df.loc[0, &#x27;Date&#x27;] + pd.Timedelta(days=1)</code></pre><p>The <code>parse_dates</code> parameter in <code>pd.read_excel()</code> ensures Excel dates import as proper Python datetime objects instead of integers or strings. This enables date arithmetic and time-based analysis in your code.</p><ul><li>Watch for this issue when your Excel files contain date columns that need mathematical operations or filtering</li><li>The error typically surfaces when date calculations fail or return unexpected results</li><li>Simply include column names in the <code>parse_dates</code> list to automatically convert them during import</li></ul><p>This approach proves more efficient than manually converting dates after import. It also handles various Excel date formats consistently across different spreadsheets.</p></div></div></div><h2>FAQs</h2><div><div><h3>What is the most commonly used library for reading Excel files in Python?</h3><div><div><div><p>The <code>pandas</code> library dominates Excel file handling in Python through its <code>read_excel()</code> function. This widespread adoption stems from pandas' seamless integration with data analysis workflows and its ability to convert Excel sheets directly into DataFrame objects.</p><p>While alternatives like <code>openpyxl</code> and <code>xlrd</code> exist, pandas leverages these libraries internally while providing a more intuitive interface. It handles complex Excel features including multiple worksheets, merged cells, and various data types—making it the clear frontrunner for Excel operations in Python.</p></div></div></div></div></div><div><div><h3>How do you install the required dependencies to read Excel files?</h3><div><div><div><p>To read Excel files in Python, install the <code>pandas</code> library using <code>pip install pandas</code>. This automatically includes <code>openpyxl</code> for newer Excel formats and <code>xlrd</code> for legacy files. The <code>pandas</code> library serves as a high-level interface, translating Excel's complex binary format into Python-friendly data structures.</p><p>For enhanced performance with large spreadsheets, consider installing <code>pyarrow</code>. This optional dependency optimizes memory usage and processing speed when handling extensive datasets.</p></div></div></div></div></div><div><div><h3>What file formats can pandas read_excel() function handle?</h3><div><div><div><p>The <code>read_excel()</code> function in pandas handles Excel workbooks in both modern and legacy formats. It supports <code>.xlsx</code> files created by Excel 2007 and later versions, as well as older <code>.xls</code> files. The function also works with <code>.xlsm</code> files containing macros and <code>.xlsb</code> binary workbooks.</p><p>This broad format support stems from pandas using the openpyxl and xlrd engines under the hood. These engines parse Excel's XML-based and binary file structures to extract data into DataFrame objects efficiently.</p></div></div></div></div></div><div><div><h3>How do you specify which worksheet to read from an Excel file with multiple sheets?</h3><div><div><div><p>You can specify a worksheet in Excel files using either the sheet name or index. The <code>sheet_name</code> parameter accepts a string with the tab name or an integer (0-based) representing the sheet's position. When working with multiple sheets, pass a list of names or indices to read several worksheets at once.</p><p>This flexibility helps when sheet names change frequently but their order remains constant. Excel files often contain both raw data and summary sheets, so targeting the right worksheet ensures you process the intended data.</p></div></div></div></div></div><div><div><h3>What happens if you don&#x27;t specify the &#x27;sheet_name&#x27; parameter when reading an Excel file?</h3><div><div><div><p>When you don't specify <code>sheet_name</code>, pandas reads the first sheet of your Excel workbook by default. This behavior stems from Excel's standard structure, where the leftmost tab typically contains the primary dataset.</p><p>This automatic selection works well for simple workbooks with a single sheet. However, for workbooks containing multiple sheets with different datasets, you'll want to explicitly specify the sheet to avoid potential data mix-ups. The default behavior essentially treats <code>sheet_name=0</code> as the implicit parameter.</p></div></div></div></div></div><h2>🏠</h2></body></html>