<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title>How to sort a dictionary in Python</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@700&amp;family=Literata:wght@400;700&amp;family=Fira+Code:wght@400;700&amp;display=swap" rel="stylesheet" type="text/css" />
  <link href="styles.css" rel="stylesheet" type="text/css" />
</head><body id="top">
  <script src="script.js"></script>
<h1><a href="index.html">How to sort a dictionary in Python</a></h1><div><div><div><p>Dictionaries store key-value pairs in Python, but their unordered nature can complicate data organization. Python provides multiple built-in methods and operators to sort dictionaries by keys, values, or both elements simultaneously.</p><p>This guide covers essential sorting techniques, practical examples, and troubleshooting tips. The code examples, created with <a href="https://claude.ai/">Claude</a>, an AI assistant built by Anthropic, demonstrate real-world dictionary sorting applications.</p><h2>Using the <code>sorted()</code> function with dictionary keys</h2><pre><code>data = {&#x27;banana&#x27;: 3, &#x27;apple&#x27;: 1, &#x27;orange&#x27;: 2, &#x27;kiwi&#x27;: 4}
sorted_dict = dict(sorted(data.items()))
print(sorted_dict)</code></pre><pre><code>{&#x27;apple&#x27;: 1, &#x27;banana&#x27;: 3, &#x27;kiwi&#x27;: 4, &#x27;orange&#x27;: 2}</code></pre><p>The <code>sorted()</code> function transforms the dictionary's unordered key-value pairs into an alphabetically sorted sequence based on the keys. When you pass <code>data.items()</code> to <code>sorted()</code>, Python compares dictionary keys using their natural ordering—alphabetical for strings and numerical for numbers.</p><p>Converting the sorted items back to a dictionary with <code>dict()</code> preserves the sorted order in Python 3.7+. This approach offers two key benefits:</p><ul><li>Maintains data relationships between keys and values during sorting</li><li>Creates predictable, consistent output for data processing and display</li></ul><h2>Basic dictionary sorting techniques</h2><p>Building on the <code>sorted()</code> function's capabilities, Python offers additional dictionary sorting patterns that give you precise control over how key-value data gets organized and processed.</p><h3>Sorting a dictionary by values</h3><pre><code>data = {&#x27;banana&#x27;: 3, &#x27;apple&#x27;: 1, &#x27;orange&#x27;: 2, &#x27;kiwi&#x27;: 4}
sorted_by_value = dict(sorted(data.items(), key=lambda item: item[1]))
print(sorted_by_value)</code></pre><pre><code>{&#x27;apple&#x27;: 1, &#x27;orange&#x27;: 2, &#x27;banana&#x27;: 3, &#x27;kiwi&#x27;: 4}</code></pre><p>The <code>key=lambda item: item[1]</code> parameter tells Python to sort dictionary items based on their values instead of keys. This creates a new dictionary where entries are ordered by ascending numeric values (1, 2, 3, 4) rather than alphabetically by keys.</p><ul><li>The <code>lambda</code> function extracts each value using <code>item[1]</code> from the key-value pairs</li><li>Python uses these extracted values as sorting criteria</li><li>The original dictionary structure remains intact. Only the order changes</li></ul><p>This technique proves especially useful when you need to rank or prioritize dictionary data based on numeric values. For example, sorting products by price or organizing player scores in a game.</p><h3>Iterating through a sorted dictionary</h3><pre><code>fruits = {&#x27;banana&#x27;: 3, &#x27;apple&#x27;: 1, &#x27;orange&#x27;: 2, &#x27;kiwi&#x27;: 4}
for key in sorted(fruits.keys()):
    print(f&quot;{key}: {fruits[key]}&quot;)</code></pre><pre><code>apple: 1
banana: 3
kiwi: 4
orange: 2</code></pre><p>The <code>sorted(fruits.keys())</code> method creates an alphabetically ordered list of dictionary keys, which the <code>for</code> loop then processes sequentially. This approach gives you direct control over the iteration order while maintaining access to both keys and values.</p><ul><li>The <code>keys()</code> method extracts all dictionary keys into a list</li><li>Python sorts these keys alphabetically using <code>sorted()</code></li><li>The f-string syntax (<code>f"{key}: {fruits[key]}"</code>) efficiently formats each key-value pair for output</li></ul><p>This pattern proves particularly useful when you need to process dictionary entries in a specific order while preserving the original data structure. The technique works consistently across different Python versions and dictionary sizes.</p><h3>Using dictionary comprehension for sorted results</h3><pre><code>prices = {&#x27;shirt&#x27;: 25, &#x27;pants&#x27;: 35, &#x27;hat&#x27;: 15, &#x27;shoes&#x27;: 45}
sorted_by_keys = {k: prices[k] for k in sorted(prices)}
sorted_by_values = {k: v for k, v in sorted(prices.items(), key=lambda x: x[1])}
print(sorted_by_values)</code></pre><pre><code>{&#x27;hat&#x27;: 15, &#x27;shirt&#x27;: 25, &#x27;pants&#x27;: 35, &#x27;shoes&#x27;: 45}</code></pre><p>Dictionary comprehension offers a concise way to create sorted dictionaries in a single line. The <code>sorted_by_keys</code> expression creates a new dictionary by sorting the keys alphabetically, while <code>sorted_by_values</code> organizes entries based on their numeric values.</p><ul><li>The <code>k: prices[k]</code> syntax maintains the connection between keys and their original values during sorting</li><li>Using <code>lambda x: x[1]</code> tells Python to sort based on the value component of each key-value pair</li><li>The output shows items arranged by ascending prices, from the $15 hat to the $45 shoes</li></ul><p>This approach combines the power of dictionary comprehension with sorting functionality. It creates cleaner, more maintainable code compared to traditional loop-based sorting methods.</p><h2>Advanced dictionary sorting methods</h2><p>Building on Python's built-in sorting capabilities, advanced techniques like <code>lambda</code> functions, nested value handling, and <code>itemgetter()</code> unlock more sophisticated ways to organize complex dictionary data.</p><h3>Implementing custom sort logic with <code>lambda</code> functions</h3><pre><code>students = {&#x27;Alice&#x27;: (85, &#x27;A&#x27;), &#x27;Bob&#x27;: (92, &#x27;A&#x27;), &#x27;Charlie&#x27;: (78, &#x27;B&#x27;), &#x27;David&#x27;: (95, &#x27;A&#x27;)}
by_grade_then_score = dict(sorted(students.items(), 
                           key=lambda x: (x[1][1], -x[1][0])))
print(by_grade_then_score)</code></pre><pre><code>{&#x27;David&#x27;: (95, &#x27;A&#x27;), &#x27;Bob&#x27;: (92, &#x27;A&#x27;), &#x27;Alice&#x27;: (85, &#x27;A&#x27;), &#x27;Charlie&#x27;: (78, &#x27;B&#x27;)}</code></pre><p>The <code>lambda</code> function in this example enables multi-level sorting of student records based on two criteria: letter grades and numerical scores. The tuple <code>(x[1][1], -x[1][0])</code> creates a compound sorting key that first groups students by their letter grade, then orders them by descending numerical scores within each grade group.</p><ul><li>The first sorting criterion <code>x[1][1]</code> accesses the letter grade ('A' or 'B')</li><li>The second criterion <code>-x[1][0]</code> uses a negative sign to sort numerical scores in descending order</li><li>Python automatically sorts tuples element by element, enabling this elegant multi-level sorting approach</li></ul><p>The output shows all 'A' students grouped together and sorted by their descending numerical scores (95, 92, 85), followed by 'B' students. This pattern proves particularly useful when organizing hierarchical data that requires multiple sorting levels.</p><h3>Sorting dictionaries with nested values</h3><pre><code>users = {
    &#x27;user1&#x27;: {&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;score&#x27;: 85, &#x27;active&#x27;: True},
    &#x27;user2&#x27;: {&#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;score&#x27;: 92, &#x27;active&#x27;: False},
    &#x27;user3&#x27;: {&#x27;name&#x27;: &#x27;Charlie&#x27;, &#x27;score&#x27;: 78, &#x27;active&#x27;: True}
}
sorted_users = dict(sorted(users.items(), key=lambda x: x[1][&#x27;score&#x27;], reverse=True))
print(sorted_users)</code></pre><pre><code>{&#x27;user2&#x27;: {&#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;score&#x27;: 92, &#x27;active&#x27;: False}, &#x27;user1&#x27;: {&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;score&#x27;: 85, &#x27;active&#x27;: True}, &#x27;user3&#x27;: {&#x27;name&#x27;: &#x27;Charlie&#x27;, &#x27;score&#x27;: 78, &#x27;active&#x27;: True}}</code></pre><p>When dictionaries contain nested data structures like in our <code>users</code> example, sorting requires accessing values within the inner dictionary. The <code>lambda</code> function extracts the <code>'score'</code> value from each user's nested dictionary using <code>x[1]['score']</code> as the sorting key.</p><ul><li>The <code>x[1]</code> part accesses the inner dictionary containing user details</li><li>Adding <code>reverse=True</code> sorts users by descending scores instead of ascending</li><li>The output maintains the complete nested structure while reordering based on scores</li></ul><p>This pattern works well for complex data structures where sorting criteria exist within nested dictionaries. The technique scales effectively for dictionaries containing multiple nested levels or different data types.</p><h3>Using <code>itemgetter()</code> for efficient sorting</h3><pre><code>from operator import itemgetter
products = {&#x27;laptop&#x27;: 1200, &#x27;phone&#x27;: 800, &#x27;tablet&#x27;: 500, &#x27;headphones&#x27;: 150}
by_price_ascending = dict(sorted(products.items(), key=itemgetter(1)))
by_price_descending = dict(sorted(products.items(), key=itemgetter(1), reverse=True))
print(by_price_descending)</code></pre><pre><code>{&#x27;laptop&#x27;: 1200, &#x27;phone&#x27;: 800, &#x27;tablet&#x27;: 500, &#x27;headphones&#x27;: 150}</code></pre><p>The <code>itemgetter()</code> function from Python's <code>operator</code> module provides a more efficient alternative to <code>lambda</code> functions when sorting dictionaries. It creates a callable object that retrieves the specified index or key from an iterable, making the sorting process faster and more readable.</p><ul><li>The argument <code>itemgetter(1)</code> extracts values from key-value pairs while <code>itemgetter(0)</code> would extract keys</li><li>Adding <code>reverse=True</code> flips the sorting order from ascending to descending</li><li>This approach performs better than equivalent <code>lambda</code> functions, especially when sorting large dictionaries</li></ul><p>In the example, <code>itemgetter(1)</code> sorts products by their prices. The output shows items arranged from highest price (laptop at 1200) to lowest (headphones at 150), demonstrating how <code>itemgetter()</code> elegantly handles numeric sorting.</p><h3>Sorting financial transactions for monthly reports using <code>lambda</code></h3><p>Financial transaction data often requires chronological organization for accurate reporting, and Python's <code>lambda</code> functions enable precise sorting of nested dictionaries by date values while preserving transaction details.</p><pre><code>transactions = {
    &#x27;tx001&#x27;: {&#x27;date&#x27;: &#x27;2023-05-15&#x27;, &#x27;amount&#x27;: 250.50},
    &#x27;tx002&#x27;: {&#x27;date&#x27;: &#x27;2023-05-05&#x27;, &#x27;amount&#x27;: -120.75},
    &#x27;tx003&#x27;: {&#x27;date&#x27;: &#x27;2023-05-20&#x27;, &#x27;amount&#x27;: -45.00},
    &#x27;tx004&#x27;: {&#x27;date&#x27;: &#x27;2023-05-02&#x27;, &#x27;amount&#x27;: 1000.00}
}

# Sort transactions by date for a financial report
sorted_by_date = dict(sorted(transactions.items(), key=lambda x: x[1][&#x27;date&#x27;]))
for tx_id, details in sorted_by_date.items():
    print(f&quot;{details[&#x27;date&#x27;]} - ${details[&#x27;amount&#x27;]:.2f}&quot;)</code></pre><p>This code demonstrates nested dictionary sorting and formatted output for financial data. The <code>transactions</code> dictionary stores transaction records with unique IDs as keys, containing dates and monetary amounts in nested dictionaries.</p><p>The sorting operation uses <code>sorted()</code> with a <code>lambda</code> function to organize transactions chronologically. The <code>lambda x: x[1]['date']</code> expression tells Python to sort based on the date value within each nested dictionary. The <code>items()</code> method converts the dictionary into sortable pairs.</p><ul><li>The <code>for</code> loop iterates through the sorted dictionary</li><li>F-string formatting (<code>:.2f</code>) ensures proper decimal display of amounts</li><li>The output presents each transaction with its date and dollar amount in chronological order</li></ul><h3>Creating a word frequency analyzer with <code>sorted()</code> and dictionaries</h3><p>Dictionary sorting enables powerful text analysis capabilities, as demonstrated in this word frequency counter that uses <code>sorted()</code> with <code>lambda</code> functions to rank words by their occurrence count in descending order.</p><pre><code>text = &quot;Python is popular. Python is powerful. Programming in Python is enjoyable.&quot;
words = text.lower().replace(&#x27;.&#x27;, &#x27;&#x27;).split()

# Build and sort a word frequency dictionary
word_freq = {}
for word in words:
    word_freq[word] = word_freq.get(word, 0) + 1

sorted_freq = dict(sorted(word_freq.items(), key=lambda x: x[1], reverse=True))
for word, count in sorted_freq.items():
    print(f&quot;{word}: {count}&quot;)</code></pre><p>This code creates a word frequency counter that processes text in three key steps. First, it converts the input string to lowercase and removes periods using <code>lower()</code> and <code>replace()</code>, then splits it into individual words with <code>split()</code>.</p><p>The core functionality uses a dictionary to track word occurrences. The <code>get()</code> method checks if a word exists in the dictionary. If not found, it returns 0 as the default value. Each time a word appears, its count increases by 1.</p><ul><li>The <code>sorted()</code> function with <code>lambda x: x[1]</code> orders words by their frequency</li><li>Setting <code>reverse=True</code> displays most frequent words first</li><li>F-strings format the output as "word: count" pairs</li></ul><h2>Common errors and challenges</h2><p>Python dictionary sorting can trigger unexpected errors and performance bottlenecks that require specific debugging strategies and optimization techniques to resolve effectively.</p><h3>Fixing <code>TypeError</code> when sorting dictionaries with <code>sorted()</code></h3><p>When sorting dictionaries, Python's <code>sorted()</code> function can raise a <code>TypeError</code> if you try to access values from the sorted output directly. This common issue occurs because <code>sorted()</code> returns only the dictionary keys by default. The code below demonstrates this error in action.</p><pre><code>data = {&#x27;banana&#x27;: 3, &#x27;apple&#x27;: 1, &#x27;orange&#x27;: 2}
sorted_data = sorted(data)
print(f&quot;Keys: {sorted_data}&quot;)
print(f&quot;Values for first key: {sorted_data[0][1]}&quot;)  # Error!</code></pre><p>The <code>sorted()</code> function returns a list of keys instead of key-value pairs. When the code attempts to access the value using <code>sorted_data[0][1]</code>, Python can't find the expected tuple structure. Let's examine the corrected approach below.</p><pre><code>data = {&#x27;banana&#x27;: 3, &#x27;apple&#x27;: 1, &#x27;orange&#x27;: 2}
sorted_keys = sorted(data)
print(f&quot;Keys: {sorted_keys}&quot;)
print(f&quot;Values for first key: {data[sorted_keys[0]]}&quot;)</code></pre><p>The corrected code accesses dictionary values by using the original dictionary <code>data</code> with sorted keys instead of trying to extract values directly from <code>sorted()</code> output. This prevents the <code>TypeError</code> that occurs when attempting to treat sorted keys as key-value pairs.</p><p>Watch for this error when working with sorted dictionaries in these scenarios:</p><ul><li>Iterating through sorted dictionary keys while needing access to values</li><li>Processing sorted dictionary data in loops or list comprehensions</li><li>Converting between dictionary views and sorted sequences</li></ul><p>The solution maintains data integrity by keeping the original dictionary structure intact while allowing ordered access through the sorted keys list.</p><h3>Handling missing keys when sorting nested dictionaries</h3><p>Sorting nested dictionaries can fail when inner dictionaries lack expected keys. This common issue triggers <code>KeyError</code> exceptions when the sorting function attempts to access missing values. The code below demonstrates how a missing <code>'score'</code> key disrupts the sorting operation.</p><pre><code>users = {
    &#x27;user1&#x27;: {&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;score&#x27;: 85},
    &#x27;user2&#x27;: {&#x27;name&#x27;: &#x27;Bob&#x27;},  # Missing &#x27;score&#x27; key
    &#x27;user3&#x27;: {&#x27;name&#x27;: &#x27;Charlie&#x27;, &#x27;score&#x27;: 78}
}
sorted_users = dict(sorted(users.items(), key=lambda x: x[1][&#x27;score&#x27;]))</code></pre><p>The <code>lambda</code> function attempts to access the <code>'score'</code> key for each user, but <code>user2</code> lacks this key. This triggers a <code>KeyError</code> exception, halting the sorting operation. Let's examine a robust solution that handles missing dictionary keys.</p><pre><code>users = {
    &#x27;user1&#x27;: {&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;score&#x27;: 85},
    &#x27;user2&#x27;: {&#x27;name&#x27;: &#x27;Bob&#x27;},  # Missing &#x27;score&#x27; key
    &#x27;user3&#x27;: {&#x27;name&#x27;: &#x27;Charlie&#x27;, &#x27;score&#x27;: 78}
}
sorted_users = dict(sorted(users.items(), key=lambda x: x[1].get(&#x27;score&#x27;, 0)))</code></pre><p>The <code>get()</code> method provides a safer way to access dictionary values by returning a default value (0 in this case) when a key doesn't exist. This prevents the <code>KeyError</code> exception that would occur with direct key access using square brackets.</p><ul><li>Watch for this error when sorting dictionaries with inconsistent data structures</li><li>Common in scenarios involving data from external sources or user input</li><li>The default value choice impacts the sorting order. Items with missing keys appear first when using 0</li></ul><p>This pattern works especially well for data cleaning and normalization tasks where missing values are common. The solution maintains code reliability without compromising sorting functionality.</p><h3>Optimizing multiple sorting operations on dictionaries</h3><p>Repeatedly sorting and filtering dictionaries can create performance bottlenecks, especially with large datasets. The code below demonstrates how multiple <code>sorted()</code> operations within a loop impact efficiency when filtering dictionary items based on different thresholds.</p><pre><code>data = {&#x27;banana&#x27;: 3, &#x27;apple&#x27;: 1, &#x27;orange&#x27;: 2, &#x27;kiwi&#x27;: 4}
for threshold in range(1, 5):
    filtered = dict(sorted(data.items(), key=lambda x: x[1]))
    result = {k: v for k, v in filtered.items() if v &gt; threshold}
    print(f&quot;Items &gt; {threshold}: {result}&quot;)</code></pre><p>The code inefficiently sorts and filters the dictionary multiple times within the loop. Each iteration creates a new sorted dictionary and filters it. This approach wastes computational resources when processing large datasets. Let's examine a more efficient implementation.</p><pre><code>data = {&#x27;banana&#x27;: 3, &#x27;apple&#x27;: 1, &#x27;orange&#x27;: 2, &#x27;kiwi&#x27;: 4}
sorted_once = sorted(data.items(), key=lambda x: x[1])
for threshold in range(1, 5):
    result = {k: v for k, v in sorted_once if v &gt; threshold}
    print(f&quot;Items &gt; {threshold}: {result}&quot;)</code></pre><p>Moving the <code>sorted()</code> operation outside the loop dramatically improves performance by sorting the dictionary only once. The sorted items remain available for all threshold checks instead of redundantly re-sorting on each iteration.</p><ul><li>Watch for this pattern when processing dictionaries in loops</li><li>Pay special attention to data processing pipelines that combine sorting with filtering</li><li>Consider caching sorted results when working with large datasets or frequent access patterns</li></ul><p>This optimization becomes particularly important when dealing with large dictionaries or when the sorting operation needs to happen frequently in your application's lifecycle.</p></div></div></div><h2>FAQs</h2><div><div><h3>What is the difference between sorted() and using the &#x27;sort&#x27; method on dictionaries?</h3><div><div><div><p>The <code>sorted()</code> function creates a new sorted list from a dictionary's keys while the <code>sort()</code> method modifies a list in place. Since dictionaries are unordered collections, you can't directly sort them. Instead, <code>sorted()</code> returns their keys in a new sorted list, preserving the original dictionary.</p><p>When working with dictionaries, <code>sorted()</code> proves more versatile since it accepts optional parameters to sort by values instead of keys. This flexibility makes it the preferred choice for dictionary operations.</p></div></div></div></div></div><div><div><h3>How do you sort a dictionary by its values instead of keys?</h3><div><div><div><p>Python's <code>sorted()</code> function transforms dictionaries into sorted lists based on values. Pass your dictionary to <code>sorted()</code> with a <code>key</code> parameter that uses <code>lambda</code> to specify the sorting criteria. The <code>dict.items()</code> method provides key-value pairs for sorting.</p><ul><li>For ascending order: <code>sorted(dict.items(), key=lambda x: x[1])</code></li><li>For descending order, add <code>reverse=True</code> parameter</li></ul><p>This approach works because <code>sorted()</code> expects an iterable input. The <code>lambda</code> function tells Python to sort based on the second element (value) instead of the first (key).</p></div></div></div></div></div><div><div><h3>Can you sort a dictionary in descending order?</h3><div><div><div><p>Python dictionaries don't maintain a fixed order by default, but you can sort them by converting to a list of items and using <code>sorted()</code> with a reverse parameter. The <code>sorted()</code> function returns a new sorted list while preserving the original dictionary.</p><ul><li>Use <code>dict.items()</code> to get key-value pairs</li><li>Apply <code>sorted()</code> with <code>reverse=True</code> for descending order</li><li>Specify a <code>key</code> parameter to sort by values instead of keys</li></ul><p>This approach creates a new sorted structure rather than modifying the original dictionary. This aligns with Python's philosophy of explicit operations over implicit ones.</p></div></div></div></div></div><div><div><h3>What happens to the original dictionary when you use sorted()?</h3><div><div><div><p>The <code>sorted()</code> function creates a new sorted list while leaving the original dictionary completely unchanged. This happens because <code>sorted()</code> works non-destructively—it takes the dictionary's keys as input but doesn't modify the source data structure.</p><p>Here's what actually occurs:</p><ul><li>Python creates a new list containing the dictionary's keys</li><li>The function sorts this new list</li><li>Your original dictionary maintains its order and content</li><li>You receive a sorted list as the return value</li></ul></div></div></div></div></div><div><div><h3>How do you sort a dictionary by both keys and values at the same time?</h3><div><div><div><p>Python's <code>sorted()</code> function accepts a dictionary and returns a sorted list of tuples. To sort by both keys and values simultaneously, pass a <code>lambda</code> function to the <code>key</code> parameter that returns a tuple of the elements you want to sort by. The sorting happens in order—first by the initial element, then by subsequent elements when there are ties.</p><p>For example, <code>sorted(my_dict.items(), key=lambda x: (x[0], x[1]))</code> sorts first by keys then values. This works because Python compares tuples element by element, making it perfect for multi-level sorting.</p></div></div></div></div></div><h2>🏠</h2></body></html>