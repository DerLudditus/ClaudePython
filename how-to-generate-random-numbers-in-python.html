<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><title>How to generate random numbers in Python</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@700&amp;family=Literata:wght@400;700&amp;family=Fira+Code:wght@400;700&amp;display=swap" rel="stylesheet" type="text/css" />
  <link href="styles.css" rel="stylesheet" type="text/css" />
</head><body id="top">
  <script src="script.js"></script>
<h1><a href="index.html">How to generate random numbers in Python</a></h1><div><div><div><p>Random number generation powers everything from cryptography to game development in Python. The language's built-in modules provide robust tools for creating both pseudo-random and true random numbers, with options for different probability distributions and ranges.</p><p>This guide covers essential techniques, practical applications, and troubleshooting tips for random number generation, featuring code examples created with <a href="https://claude.ai/">Claude</a>, an AI assistant built by Anthropic.</p><h2>Basic random numbers with <code>random.random()</code></h2><pre><code>import random
random_number = random.random()
print(random_number)</code></pre><pre><code>0.7237845954323937</code></pre><p>The <code>random.random()</code> function generates a floating-point number between 0.0 and 1.0, following a uniform distribution where each value has an equal probability of being selected. This fundamental random number generator serves as a building block for creating random values in other ranges or distributions.</p><p>Python's random module uses the Mersenne Twister algorithm to produce these numbers. While not cryptographically secure, it provides sufficient randomness for most general applications like:</p><ul><li>Simulating probability-based events</li><li>Generating test data</li><li>Creating random selections from datasets</li><li>Building simple games and animations</li></ul><h2>Basic random number techniques</h2><p>Building on the basic <code>random.random()</code> function, Python's random module provides specialized methods for generating integers, floats within ranges, and random selections from sequences.</p><h3>Generating integers with <code>random.randint()</code></h3><pre><code>import random
random_integer = random.randint(1, 100)
print(random_integer)</code></pre><pre><code>42</code></pre><p>The <code>random.randint()</code> function generates random integers within a specified inclusive range. Unlike <code>random.random()</code>, it returns whole numbers instead of decimals.</p><p>When calling <code>random.randint(1, 100)</code>, Python selects a random integer between 1 and 100, including both endpoints. Each number has an equal probability of being chosen.</p><ul><li>Both arguments must be integers</li><li>The first number must be less than or equal to the second</li><li>The function includes both boundary values in its selection pool</li></ul><p>This makes <code>randint()</code> particularly useful for simulating dice rolls, generating random ages, or creating test data that requires whole numbers within specific bounds.</p><h3>Creating random floats in a range with <code>random.uniform()</code></h3><pre><code>import random
random_float = random.uniform(1.5, 8.5)
print(random_float)</code></pre><pre><code>5.273546789123456</code></pre><p>The <code>random.uniform()</code> function generates floating-point numbers within a specified range, giving you precise control over the minimum and maximum values. Unlike <code>random.random()</code>, you can define any numerical boundaries you need.</p><ul><li>The function takes two parameters: a minimum and maximum value</li><li>It returns a random float that includes the minimum but not the maximum value</li><li>Each possible float within the range has an equal probability of being selected</li></ul><p>In the example, <code>random.uniform(1.5, 8.5)</code> produces a random decimal number between 1.5 and 8.5. This makes it ideal for simulating measurements, calculating prices, or generating test data that requires decimal precision.</p><h3>Selecting random elements with <code>random.choice()</code></h3><pre><code>import random
fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;date&quot;, &quot;elderberry&quot;]
random_fruit = random.choice(fruits)
print(random_fruit)</code></pre><pre><code>banana</code></pre><p>The <code>random.choice()</code> function selects a single random element from any sequence like a list, tuple, or string. Each item has an equal probability of being chosen.</p><p>In the example, <code>random.choice(fruits)</code> randomly picks one fruit from the list and assigns it to <code>random_fruit</code>. The function handles all the complexity of generating random indices internally.</p><ul><li>Works with any sequence type in Python</li><li>Returns exactly one element each time it's called</li><li>Raises an error if the sequence is empty</li></ul><p>This makes <code>random.choice()</code> perfect for simulating random selections, creating game mechanics, or sampling data points from collections.</p><h2>Advanced random number techniques</h2><p>Building on these foundational techniques, Python offers powerful tools for generating large arrays of random numbers, working with statistical distributions, and creating reproducible results through seeding.</p><h3>Generating arrays of random numbers with NumPy</h3><pre><code>import numpy as np
random_array = np.random.random(5)
print(random_array)</code></pre><pre><code>[0.12345678 0.23456789 0.34567891 0.45678912 0.56789123]</code></pre><p>NumPy's <code>random.random()</code> function efficiently generates arrays of random floating-point numbers between 0 and 1. The integer argument specifies how many random numbers to create. In this case, <code>np.random.random(5)</code> produces an array containing exactly 5 random values.</p><ul><li>NumPy arrays process data much faster than Python lists for large-scale random number generation</li><li>The generated numbers follow a uniform distribution, giving each value an equal probability</li><li>You can reshape these arrays into different dimensions for matrices or multi-dimensional data structures</li></ul><p>This approach proves especially valuable when you need to generate thousands or millions of random numbers for simulations, data analysis, or machine learning applications. NumPy's optimized C backend handles the heavy lifting, making it significantly more efficient than using Python's built-in random module in a loop.</p><h3>Creating random numbers with specific distributions</h3><pre><code>import numpy as np
normal_distribution = np.random.normal(0, 1, 5)
print(normal_distribution)</code></pre><pre><code>[-0.12345678  0.23456789 -1.34567891  0.45678912  1.56789123]</code></pre><p>NumPy's <code>random.normal()</code> function generates random numbers that follow a normal (Gaussian) distribution. The function takes three key parameters: mean (center of the distribution), standard deviation (spread), and size (number of samples).</p><p>In the example, <code>np.random.normal(0, 1, 5)</code> creates 5 random numbers centered around 0 with a standard deviation of 1. This produces values that cluster around the mean, with decreasing probability as numbers get further from 0.</p><ul><li>Values have a higher chance of being close to the mean (0)</li><li>About 68% of values fall within one standard deviation of the mean</li><li>The distribution creates a classic bell curve pattern</li></ul><p>This type of distribution proves invaluable when modeling real-world phenomena like measurement errors, natural variations, or financial market movements that tend to follow normal patterns.</p><h3>Setting seeds for reproducible random numbers</h3><pre><code>import random
import numpy as np
random.seed(42)
np.random.seed(42)
print(random.random())
print(np.random.random())</code></pre><pre><code>0.6394267984578837
0.37454011884736133</code></pre><p>Setting a random seed ensures your random numbers follow the same sequence every time you run your code. The <code>random.seed()</code> and <code>np.random.seed()</code> functions initialize this sequence with a number of your choice.</p><ul><li>Seeds make random operations reproducible. Running the same seed produces identical results across different executions</li><li>This reproducibility proves essential for debugging, testing, and scientific experiments</li><li>Both Python's random module and NumPy need separate seed initialization for consistent results</li></ul><p>The example uses seed 42. Any value works, but 42 appears frequently in examples because of its cultural significance. Each subsequent call to <code>random()</code> or <code>np.random.random()</code> will generate the same "random" numbers in sequence.</p><h3>Generating random passwords with <code>random.choice()</code></h3><p>The <code>random.choice()</code> function enables secure password generation by randomly selecting characters from custom character sets, allowing you to create strong passwords that meet specific complexity requirements.</p><pre><code>import random
import string
characters = string.ascii_letters + string.digits + string.punctuation
password = &#x27;&#x27;.join(random.choice(characters) for _ in range(12))
print(password)</code></pre><p>This code combines Python's built-in <code>string</code> and <code>random</code> modules to create a random string. The <code>string.ascii_letters</code> contains all letters (both cases), <code>string.digits</code> provides numbers 0-9, and <code>string.punctuation</code> adds special characters. These combine into a single string stored in <code>characters</code>.</p><p>The core functionality uses a generator expression with <code>random.choice()</code> to select 12 random characters from this pool. The <code>join()</code> method then combines these selections into the final string. This approach ensures the password includes a diverse mix of character types.</p><ul><li>The underscore variable <code>_</code> indicates we don't need the loop variable</li><li>The empty string <code>''</code> serves as the separator between joined characters</li><li>Each run produces a unique 12-character string</li></ul><h3>Estimating π with Monte Carlo simulation</h3><p>Monte Carlo simulation estimates the value of π by randomly plotting points inside a square containing a quarter circle, then calculating the ratio between points that fall inside versus outside the circle.</p><pre><code>import random
import math

points = 10000
inside_circle = sum(1 for _ in range(points) if random.random()**2 + random.random()**2 &lt;= 1)
pi_estimate = 4 * inside_circle / points
print(f&quot;Estimated π: {pi_estimate}&quot;)
print(f&quot;Math.pi: {math.pi}&quot;)</code></pre><p>This code uses random number generation to approximate the mathematical constant π through a probability-based approach. The program generates 10,000 random points within a 1x1 square using <code>random.random()</code>. It then calculates how many points fall inside a quarter circle with radius 1 by checking if the squared coordinates sum to less than or equal to 1.</p><p>The ratio of points inside the circle to total points, multiplied by 4, gives us an estimate of π. This works because the ratio of the quarter circle's area to the square's area equals π/4. More points generally yield more accurate estimates.</p><ul><li>The <code>sum()</code> function with a generator expression efficiently counts qualifying points</li><li>The <code>**2</code> operator squares the random coordinates</li><li>The program compares the estimate to Python's built-in <code>math.pi</code> constant</li></ul><h2>Common errors and challenges</h2><p>Python developers frequently encounter three critical random number generation pitfalls that can derail their code's reliability and functionality.</p><h3>Forgetting to set a seed with <code>random.seed()</code> for reproducible results</h3><p>When developers skip setting a random seed, their code produces different results with each execution. This makes debugging nearly impossible and creates inconsistent test outcomes. The <code>random.seed()</code> function solves this by initializing the random number generator to a known state.</p><pre><code>import random

# Different results each time the script runs
result1 = random.randint(1, 100)
# If we run the script again, we can&#x27;t reproduce the same numbers
print(f&quot;Random number: {result1}&quot;)</code></pre><p>Without a seed value, the <code>random.randint()</code> function generates unpredictable numbers that change with each program execution. This makes it impossible to replicate specific test cases or debug random number-dependent code. The solution appears in the code below.</p><pre><code>import random

# Set seed for reproducibility
random.seed(42)
result1 = random.randint(1, 100)
# Same seed will produce the same sequence of random numbers
print(f&quot;Reproducible random number: {result1}&quot;)</code></pre><p>Setting <code>random.seed(42)</code> initializes the random number generator to a specific starting point. This ensures your code produces identical random numbers in the same sequence every time it runs. The seed value itself doesn't matter. What matters is using the same seed consistently throughout your testing and debugging process.</p><ul><li>Always set seeds when writing unit tests that involve randomization</li><li>Use seeds during development to reproduce and fix bugs involving random numbers</li><li>Remember that different Python versions might produce different sequences even with the same seed</li></ul><p>Watch for this issue when your code needs predictable results or when collaborating with other developers who need to replicate your random number sequences.</p><h3>Confusion between <code>random.randint()</code> and <code>random.randrange()</code> boundaries</h3><p>Developers often mix up the boundary behaviors of Python's random number functions. The key difference lies in their ranges: <code>random.randint()</code> includes both endpoints while <code>random.randrange()</code> excludes the upper bound. This distinction causes unexpected results when generating random integers.</p><pre><code>import random
# Trying to get random number between 1 and 10
value1 = random.randint(1, 10)  # Includes 10
value2 = random.randrange(1, 10)  # Excludes 10
print(f&quot;Values: {value1}, {value2}&quot;)</code></pre><p>The code demonstrates how <code>randint()</code> and <code>randrange()</code> produce different outputs for seemingly identical ranges. This unexpected behavior can lead to off-by-one errors in your programs. Let's examine the corrected implementation below.</p><pre><code>import random
# Getting random number between 1 and 10
value1 = random.randint(1, 10)  # Includes 10
value2 = random.randrange(1, 11)  # Now includes 10
print(f&quot;Values: {value1}, {value2}&quot;)</code></pre><p>To include the number 10 in the range when using <code>random.randrange()</code>, you must specify an upper bound of 11 instead of 10. This adjustment compensates for the function's exclusive upper boundary behavior. The corrected code demonstrates both approaches achieving the same outcome: <code>random.randint(1, 10)</code> and <code>random.randrange(1, 11)</code> will both generate numbers from 1 to 10 inclusive.</p><ul><li>Always verify the boundary behavior when switching between these functions</li><li>Consider using <code>randint()</code> for simpler inclusive ranges</li><li>Watch for this issue when porting code between different random number generators</li></ul><h3>Error when using <code>random.sample()</code> with sample size larger than population</h3><p>The <code>random.sample()</code> function generates unique random selections from a sequence. A common error occurs when developers request more items than exist in the source population. This raises a <code>ValueError</code> that can crash your program unexpectedly.</p><pre><code>import random
fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]
# Trying to get 5 random fruits from a list of 3
random_fruits = random.sample(fruits, 5)
print(random_fruits)</code></pre><p>The <code>random.sample()</code> function raises a <code>ValueError</code> because it can't select 5 unique items from a list containing only 3 fruits. The code below demonstrates the proper way to handle this limitation.</p><pre><code>import random
fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]
# Sample safely with min() function
sample_size = min(5, len(fruits))
random_fruits = random.sample(fruits, sample_size)
print(random_fruits)</code></pre><p>The <code>min()</code> function provides an elegant solution by dynamically adjusting the sample size to match the available items. This prevents the <code>ValueError</code> while still returning as many unique random selections as possible from the source sequence.</p><ul><li>Always verify your sample size doesn't exceed the population size</li><li>Consider using error handling with <code>try-except</code> blocks for more complex scenarios</li><li>Watch for this issue when working with user-defined sample sizes or dynamic collections</li></ul><p>This pattern proves especially useful in data processing applications where the size of input collections may vary. The solution maintains the random selection's integrity while gracefully handling edge cases.</p></div></div></div><h2>FAQs</h2><div><div><h3>What is the difference between random() and randint() functions?</h3><div><div><div><p>The <code>random()</code> function generates a floating-point number between 0 and 1, making it ideal for probability calculations and normalized ranges. In contrast, <code>randint()</code> produces whole numbers within a specified range, which better suits tasks like simulating dice rolls or selecting array indices.</p><ul><li>Use <code>random()</code> when you need decimal precision or want to scale results to any range</li><li>Choose <code>randint()</code> for generating integers within defined boundaries without manual rounding</li></ul><p>This fundamental difference shapes how we handle randomization in practical applications—from statistical sampling to game development.</p></div></div></div></div></div><div><div><h3>How do you set a seed for reproducible random number generation?</h3><div><div><div><p>Random number generators use mathematical algorithms that produce predictable sequences when initialized with the same starting value. Setting this value—called a seed—with functions like <code>random.seed()</code> ensures your random numbers remain consistent across program runs.</p><p>This reproducibility proves essential for debugging, testing, and scientific computing where you need to replicate exact results. The seed value itself can be any integer, but many developers use meaningful numbers like timestamps or experiment IDs to track different random sequences.</p></div></div></div></div></div><div><div><h3>Can you generate random numbers within a specific range using uniform()?</h3><div><div><div><p>The <code>uniform()</code> function generates random numbers within a specified range using uniform distribution. This means each value in the range has an equal probability of being selected—making it ideal for simulations and games where fairness matters.</p><p>You can control both the lower and upper bounds of the generated numbers. For example, <code>uniform(1, 10)</code> produces random floating-point values between 1 and 10, while <code>uniform(0, 1)</code> creates numbers between 0 and 1. The distribution remains consistent across the entire range, ensuring unbiased randomization.</p></div></div></div></div></div><div><div><h3>What&#x27;s the purpose of the &#x27;random&#x27; module in Python?</h3><div><div><div><p>The <code>random</code> module generates pseudo-random numbers in Python, enabling you to simulate chance and uncertainty in your programs. It powers everything from games to scientific simulations.</p><ul><li>The module uses a deterministic algorithm that produces numbers that appear random but follow a predictable sequence when given the same starting point (seed)</li><li>This predictability makes testing and debugging easier while still providing the randomness needed for most applications</li><li>Common functions include <code>random()</code> for floating-point numbers and <code>randint()</code> for integers within a specified range</li></ul></div></div></div></div></div><div><div><h3>How do you generate random floating-point numbers between 0 and 1?</h3><div><div><div><p>Most programming languages generate random floating-point numbers between 0 and 1 using a uniform distribution. The <code>random()</code> function produces a sequence of pseudorandom numbers using a deterministic algorithm. Each number appears random but follows a mathematical pattern that eventually repeats.</p><p>For true randomness in critical applications like cryptography, specialized hardware generates random numbers from unpredictable physical processes. The standard <code>random()</code> works well for most everyday needs: simulations, games, and statistical sampling.</p></div></div></div></div></div><h2>🏠</h2></body></html>