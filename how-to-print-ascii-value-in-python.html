<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><title>How to print the ASCII value in Python</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@700&amp;family=Literata:wght@400;700&amp;family=Fira+Code:wght@400;700&amp;display=swap" rel="stylesheet" type="text/css" />
  <link href="styles.css" rel="stylesheet" type="text/css" />
</head><body id="top">
  <script src="script.js"></script>
<h1><a href="index.html">How to print the ASCII value in Python</a></h1><div><div><div><p>ASCII values represent characters as numeric codes in Python, enabling text processing and character manipulation. The Python standard library provides built-in functions like <code>ord()</code> and <code>chr()</code> to convert between characters and their ASCII equivalents.</p><p>This guide covers essential techniques for printing ASCII values, with practical examples and troubleshooting tips. All code examples were developed with <a href="https://claude.ai/">Claude</a>, an AI assistant built by Anthropic.</p><h2>Using the <code>ord()</code> function to get ASCII values</h2><pre><code>character = &#x27;A&#x27;
ascii_value = ord(character)
print(f&quot;The ASCII value of &#x27;{character}&#x27; is {ascii_value}&quot;)</code></pre><pre><code>The ASCII value of &#x27;A&#x27; is 65</code></pre><p>The <code>ord()</code> function converts a single character into its corresponding ASCII decimal value. In the example, it transforms the character 'A' into 65, which represents its position in the ASCII character encoding scheme.</p><p>This conversion serves several practical purposes in text processing:</p><ul><li>Performing character-based calculations and comparisons</li><li>Implementing custom text encoding algorithms</li><li>Validating input strings based on ASCII ranges</li><li>Converting between different character representations</li></ul><p>The f-string output demonstrates a common pattern for debugging and educational purposes. It displays both the original character and its ASCII value, helping developers understand the relationship between text and its numeric representation.</p><h2>Basic ASCII conversion techniques</h2><p>Building on the <code>ord()</code> function's capabilities, Python offers several essential techniques for converting between strings and ASCII values, enabling flexible text manipulation across different character ranges.</p><h3>Converting a string to a list of ASCII values</h3><pre><code>text = &quot;Hello&quot;
ascii_values = [ord(char) for char in text]
print(f&quot;ASCII values of &#x27;{text}&#x27;: {ascii_values}&quot;)</code></pre><pre><code>ASCII values of &#x27;Hello&#x27;: [72, 101, 108, 108, 111]</code></pre><p>This code demonstrates a list comprehension that transforms each character in a string into its ASCII value. The <code>[ord(char) for char in text]</code> syntax creates a new list by applying the <code>ord()</code> function to every character in the input string.</p><ul><li>The string "Hello" gets processed character by character</li><li>Each letter converts to its corresponding ASCII decimal number</li><li>The resulting list contains five integers representing H, e, l, l, o</li></ul><p>This technique proves particularly useful when you need to analyze text patterns or implement character-based algorithms. The f-string output provides a clear view of how the original text maps to its numeric ASCII representation.</p><h3>Converting ASCII values back to characters with <code>chr()</code></h3><pre><code>ascii_values = [65, 66, 67, 68]
text = &#x27;&#x27;.join(chr(value) for value in ascii_values)
print(f&quot;ASCII values {ascii_values} converted to text: {text}&quot;)</code></pre><pre><code>ASCII values [65, 66, 67, 68] converted to text: ABCD</code></pre><p>The <code>chr()</code> function reverses ASCII conversion by transforming numeric values back into characters. This example demonstrates how to convert a list of ASCII values into their corresponding text representation.</p><ul><li>The <code>chr(value)</code> generator expression processes each number in the list</li><li>Python's <code>join()</code> method combines the resulting characters into a single string</li><li>The empty string <code>''</code> serves as the separator between joined characters</li></ul><p>This technique proves invaluable when working with data that stores text as numeric ASCII values. The output shows how [65, 66, 67, 68] transforms into "ABCD", making it easier to display or process text-based information in a human-readable format.</p><h3>Working with ASCII ranges</h3><pre><code># Print uppercase letters and their ASCII values
for value in range(65, 91):
    print(f&quot;{chr(value)}: {value}&quot;, end=&quot;  &quot;)</code></pre><pre><code>A: 65  B: 66  C: 67  D: 68  E: 69  F: 70  G: 71  H: 72  I: 73  J: 74  K: 75  L: 76  M: 77  N: 78  O: 79  P: 80  Q: 81  R: 82  S: 83  T: 84  U: 85  V: 86  W: 87  X: 88  Y: 89  Z: 90</code></pre><p>The code demonstrates how to systematically print all uppercase letters alongside their ASCII values. The <code>range(65, 91)</code> function generates numbers from 65 (ASCII for 'A') to 90 (ASCII for 'Z'), creating a sequence that maps to the uppercase alphabet.</p><ul><li>The <code>chr(value)</code> function converts each number back to its letter representation</li><li>The f-string formats each pair of letter and ASCII value together</li><li>Setting <code>end=" "</code> in the print statement creates a space-separated output instead of new lines</li></ul><p>This pattern proves particularly useful when you need to work with specific character ranges or implement character validation. Understanding these ASCII ranges helps you process text data more effectively in your applications.</p><h2>Advanced ASCII manipulation techniques</h2><p>Building on the foundational ASCII techniques, Python offers powerful ways to map, visualize, and convert ASCII values through dictionary comprehensions, binary representations, and hexadecimal transformations.</p><h3>Using dictionary comprehensions for ASCII mapping</h3><pre><code># Create a mapping of characters to ASCII values
text = &quot;Python&quot;
ascii_map = {char: ord(char) for char in text}
print(ascii_map)</code></pre><pre><code>{&#x27;P&#x27;: 80, &#x27;y&#x27;: 121, &#x27;t&#x27;: 116, &#x27;h&#x27;: 104, &#x27;o&#x27;: 111, &#x27;n&#x27;: 110}</code></pre><p>Dictionary comprehensions create a mapping between characters and their ASCII values in a single, readable line. The <code>{char: ord(char) for char in text}</code> syntax generates key-value pairs where each character becomes a key linked to its ASCII equivalent.</p><ul><li>Each character in "Python" serves as a dictionary key</li><li>The <code>ord()</code> function converts each character to its ASCII value</li><li>The resulting dictionary makes character-to-ASCII lookups efficient</li></ul><p>This technique proves particularly useful when you need to analyze character frequencies or implement custom character encoding schemes. The dictionary structure provides instant access to ASCII values without repeatedly calling <code>ord()</code> on the same characters.</p><h3>Creating a simple ASCII table with binary representation</h3><pre><code>for i in range(33, 48):
    char = chr(i)
    binary = bin(i)[2:].zfill(8)
    print(f&quot;{i:3d} | {char:^3} | {binary}&quot;)</code></pre><pre><code>33 |  !  | 00100001
 34 |  &quot;  | 00100010
 35 |  #  | 00100011
 36 |  $  | 00100100
 37 |  %  | 00100101
 38 |  &amp;  | 00100110
 39 |  &#x27;  | 00100111
 40 |  (  | 00101000
 41 |  )  | 00101001
 42 |  *  | 00101010
 43 |  +  | 00101011
 44 |  ,  | 00101100
 45 |  -  | 00101101
 46 |  .  | 00101110
 47 |  /  | 00101111</code></pre><p>This code generates a formatted ASCII table displaying characters between ASCII values 33 and 47. The <code>range(33, 48)</code> function creates a sequence of numbers representing printable ASCII symbols like !, @, and #.</p><ul><li>The <code>chr(i)</code> function converts each number to its corresponding character</li><li>The <code>bin(i)[2:]</code> converts the ASCII value to binary. The <code>[2:]</code> slice removes the "0b" prefix</li><li>The <code>zfill(8)</code> method pads the binary number with leading zeros to ensure 8-bit representation</li><li>The f-string formats each row with aligned columns using <code>{i:3d}</code> for decimal numbers and <code>{char:^3}</code> for centered characters</li></ul><p>This visualization helps developers understand the relationship between decimal ASCII values, their character representations, and underlying binary patterns. The table format makes it easy to spot patterns in the binary progression.</p><h3>Converting between ASCII and hexadecimal values</h3><pre><code>text = &quot;ASCII&quot;
hex_values = [hex(ord(char)) for char in text]
print(f&quot;Hexadecimal ASCII values of &#x27;{text}&#x27;: {hex_values}&quot;)
print(f&quot;Back to text: {&#x27;&#x27;.join(chr(int(h, 16)) for h in hex_values)}&quot;)</code></pre><pre><code>Hexadecimal ASCII values of &#x27;ASCII&#x27;: [&#x27;0x41&#x27;, &#x27;0x53&#x27;, &#x27;0x43&#x27;, &#x27;0x49&#x27;, &#x27;0x49&#x27;]
Back to text: ASCII</code></pre><p>The code demonstrates bidirectional conversion between ASCII characters and their hexadecimal representations. The list comprehension <code>[hex(ord(char))]</code> first converts each character to its ASCII value using <code>ord()</code>, then transforms it to hexadecimal using <code>hex()</code>.</p><ul><li>The <code>hex()</code> function adds a '0x' prefix to indicate hexadecimal notation</li><li>Converting back to text requires two steps: <code>int(h, 16)</code> transforms hex to decimal. <code>chr()</code> then converts the decimal to a character</li><li>The empty string <code>''</code> joins the converted characters into the final text</li></ul><p>This technique proves valuable when working with systems that represent text in hexadecimal format. Common applications include debugging binary data or implementing custom encoding schemes.</p><h3>Creating a simple Caesar cipher with <code>ord()</code> and <code>chr()</code></h3><p>The Caesar cipher shifts each letter in a message by a fixed number of positions in the alphabet, demonstrating how <code>ord()</code> and <code>chr()</code> functions enable basic text encryption through ASCII value manipulation.</p><pre><code>message = &quot;HELLO&quot;
shift = 3
encrypted = &quot;&quot;
for char in message:
    ascii_value = ord(char)
    shifted_value = (ascii_value - 65 + shift) % 26 + 65
    encrypted += chr(shifted_value)
print(f&quot;Original: {message}\nEncrypted: {encrypted}&quot;)</code></pre><p>This code transforms text by shifting each letter forward in the alphabet by a specified number of positions. The <code>ord()</code> function converts each character to its ASCII value. Since uppercase letters start at ASCII value 65 ('A'), the code subtracts 65 to work with values 0-25 instead.</p><ul><li>The modulo operator <code>% 26</code> ensures the shift wraps around the alphabet</li><li>Adding 65 back converts the number to the correct ASCII value</li><li>The <code>chr()</code> function transforms the shifted ASCII value back into a character</li></ul><p>For example, with a shift of 3, 'A' becomes 'D', 'B' becomes 'E', and 'Z' wraps around to 'C'. The f-string displays both the original and encrypted messages.</p><h3>Implementing URL encoding with ASCII values</h3><p>URL encoding transforms special characters into percent-encoded ASCII values, enabling safe transmission of text data across web protocols by converting spaces, symbols, and non-alphanumeric characters into their hexadecimal representations.</p><pre><code>url_text = &quot;Hello World! @&quot;
encoded = &quot;&quot;
for char in url_text:
    if char.isalnum():
        encoded += char
    else:
        encoded += f&quot;%{ord(char):02X}&quot;
print(f&quot;Original: {url_text}\nEncoded: {encoded}&quot;)</code></pre><p>This code implements a basic URL encoder that processes text character by character. The <code>isalnum()</code> function checks if each character is alphanumeric (a-z, A-Z, 0-9). When it finds a non-alphanumeric character like spaces or symbols, it converts them to their hexadecimal ASCII representation prefixed with "%".</p><ul><li>The <code>:02X</code> format specifier ensures two-digit uppercase hexadecimal output</li><li>Regular letters and numbers remain unchanged</li><li>Special characters transform into their percent-encoded equivalents</li></ul><p>For example, running this code converts spaces to "%20" and exclamation marks to "%21". This encoding makes text safe for use in URLs by replacing problematic characters with their ASCII-based alternatives.</p><h2>Common errors and challenges</h2><p>Python developers frequently encounter three critical challenges when working with ASCII values: handling Unicode characters, managing character conversion errors, and preventing numeric overflows.</p><h3>Handling non-ASCII characters with <code>ord()</code></h3><p>The <code>ord()</code> function works seamlessly with standard ASCII characters but raises challenges with extended Unicode symbols like accented letters or emojis. When processing text that might contain non-ASCII characters, developers need robust error handling to prevent unexpected crashes.</p><pre><code>text = &quot;Café&quot;
try:
    for char in text:
        if ord(char) &gt; 127:
            raise ValueError(f&quot;Non-ASCII character detected: {char}&quot;)
    print(&quot;Text contains only ASCII characters&quot;)
except ValueError as e:
    print(e)</code></pre><p>The code raises a <code>ValueError</code> when it encounters the 'é' character because its Unicode value exceeds 127, the maximum value for standard ASCII characters. Let's examine the improved code below that handles these extended characters properly.</p><pre><code>text = &quot;Café&quot;
non_ascii = [char for char in text if ord(char) &gt; 127]
if non_ascii:
    print(f&quot;Non-ASCII characters found: {non_ascii}&quot;)
    ascii_only = &#x27;&#x27;.join(char for char in text if ord(char) &lt;= 127)
    print(f&quot;ASCII-only version: {ascii_only}&quot;)
else:
    print(&quot;Text contains only ASCII characters&quot;)</code></pre><p>The improved code identifies non-ASCII characters by checking if their <code>ord()</code> values exceed 127. It stores these characters in a list and creates an ASCII-only version of the text by filtering them out. This approach prevents crashes while preserving as much of the original text as possible.</p><ul><li>Watch for this issue when processing user input or external data sources</li><li>Text from web forms, files, or APIs often contains non-ASCII characters</li><li>Consider using Unicode-aware functions like <code>encode()</code> and <code>decode()</code> for more complex text processing needs</li></ul><h3>Fixing incorrect ASCII to character conversion with <code>chr()</code></h3><p>Converting strings of ASCII values to characters requires careful handling of the input format. The <code>chr()</code> function expects individual integers. When processing space-separated ASCII values as strings, direct conversion attempts will fail. The code below demonstrates this common pitfall.</p><pre><code>values = &quot;65 66 67 68&quot;
text = &#x27;&#x27;.join(chr(int(value)) for value in values)
print(f&quot;Converted text: {text}&quot;)</code></pre><p>The code fails because <code>values.split()</code> isn't used to separate the ASCII numbers. The <code>for</code> loop processes each character in the string individually, including spaces. This causes Python to attempt converting invalid ASCII values.</p><p>The corrected implementation below demonstrates the proper way to handle space-separated ASCII values.</p><pre><code>values = &quot;65 66 67 68&quot;
text = &#x27;&#x27;.join(chr(int(value)) for value in values.split())
print(f&quot;Converted text: {text}&quot;)</code></pre><p>The <code>split()</code> method separates the space-delimited ASCII values into individual numbers before conversion. Without it, Python would process each character individually, including spaces, leading to invalid ASCII values. The corrected code joins the characters after properly converting each ASCII value.</p><ul><li>Watch for this when processing ASCII values from files or user input</li><li>Always validate input format before conversion</li><li>Consider using error handling to catch potential conversion issues</li></ul><p>This pattern appears frequently when working with data from external sources that provide ASCII values as text strings. The solution ensures reliable character conversion while maintaining code readability.</p><h3>Preventing overflow errors in ASCII arithmetic operations</h3><p>ASCII arithmetic operations can produce unexpected results when calculations push values beyond valid ASCII ranges. When adding or subtracting from ASCII values, the <code>chr()</code> function may receive numbers outside its acceptable input range of 0-1,114,111. The code below demonstrates this common pitfall with character shifting.</p><pre><code>message = &quot;z{|}&quot;
shift = 5
encrypted = &quot;&quot;
for char in message:
    shifted_value = ord(char) + shift
    encrypted += chr(shifted_value)
print(f&quot;Original: {message}\nEncrypted: {encrypted}&quot;)</code></pre><p>The code fails when <code>shifted_value</code> exceeds the maximum valid ASCII value, producing characters outside the printable range. Let's examine a corrected version that implements proper value checking and wrapping.</p><pre><code>message = &quot;z{|}&quot;
shift = 5
encrypted = &quot;&quot;
for char in message:
    shifted_value = ((ord(char) - 32 + shift) % 95) + 32
    encrypted += chr(shifted_value)
print(f&quot;Original: {message}\nEncrypted: {encrypted}&quot;)</code></pre><p>The corrected code prevents overflow errors by constraining shifted ASCII values within the printable character range (32-126). The formula <code>((ord(char) - 32 + shift) % 95) + 32</code> ensures characters wrap around this range instead of exceeding valid ASCII values.</p><ul><li>Subtracting 32 normalizes the range to 0-94</li><li>The modulo operator <code>% 95</code> handles wrapping</li><li>Adding 32 back shifts values to the printable range</li></ul><p>Watch for this issue when implementing character shifting operations or text transformations. The error commonly occurs in encryption algorithms, text formatting utilities, and character manipulation functions that modify ASCII values.</p></div></div></div><h2>FAQs</h2><div><div><h3>What is the difference between ord() and chr() functions?</h3><div><div><div><p>The <code>ord()</code> function converts a single character to its Unicode code point number, while <code>chr()</code> does the opposite by converting a number back into its corresponding character. Think of them as translators between human-readable characters and the numerical values computers use internally.</p><ul><li>When you pass 'A' to <code>ord()</code>, it returns 65—the Unicode number representing that character</li><li><code>chr()</code> takes a number like 65 and returns 'A', making it useful for working with character encodings or generating specific characters programmatically</li></ul></div></div></div></div></div><div><div><h3>How do you convert a character to its ascii value using ord()?</h3><div><div><div><p>The <code>ord()</code> function converts a single character to its corresponding ASCII decimal value. When you pass a character like 'A' to <code>ord()</code>, it returns the integer 65—this represents that character's position in the ASCII table.</p><ul><li>The function accepts exactly one character as input. Passing multiple characters will raise an error.</li><li>ASCII values range from 0 to 127, mapping common characters like letters, numbers, and symbols to specific integers.</li></ul><p>This conversion enables text processing at the byte level, making it useful for encryption, data validation, and character manipulation tasks.</p></div></div></div></div></div><div><div><h3>Can you print ascii values for multiple characters at once?</h3><div><div><div><p>Yes, you can print ASCII values for multiple characters simultaneously using Python's built-in functions. The <code>ord()</code> function converts a single character to its ASCII value, while list comprehension lets you process multiple characters efficiently.</p><ul><li>Create a string with your target characters</li><li>Use <code>[ord(char) for char in string]</code> to get all ASCII values at once</li><li>Print the resulting list of values</li></ul><p>This approach works because Python iterates through each character in the string, applying the <code>ord()</code> function to each one before collecting the results in a list.</p></div></div></div></div></div><div><div><h3>What happens when you use ord() with special characters like spaces or symbols?</h3><div><div><div><p>The <code>ord()</code> function converts any Unicode character into its decimal code point value. When you use it with special characters, it returns their unique numeric representation in the Unicode standard. A space returns 32, while symbols like @ yield 64.</p><p>This behavior stems from how computers internally store text—every character maps to a specific number in the Unicode table. Understanding these mappings helps when working with text processing, character validation, or building custom encoding schemes.</p></div></div></div></div></div><div><div><h3>How do you handle uppercase and lowercase letters differently when printing ascii values?</h3><div><div><div><p>ASCII values for uppercase letters range from 65 (<code>A</code>) to 90 (<code>Z</code>), while lowercase letters span 97 (<code>a</code>) to 122 (<code>z</code>). This 32-point difference creates a mathematical relationship you can leverage for case conversion.</p><ul><li>Adding 32 to an uppercase letter's ASCII value produces its lowercase equivalent</li><li>Subtracting 32 from a lowercase letter's ASCII value yields its uppercase counterpart</li></ul><p>This consistent pattern enables efficient case manipulation in text processing applications, whether you're building a text editor or implementing search functionality.</p></div></div></div></div></div><h2>🏠</h2></body></html>