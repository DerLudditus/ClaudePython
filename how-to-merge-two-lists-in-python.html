<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><title>How to merge two lists in Python</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@700&amp;family=Literata:wght@400;700&amp;family=Fira+Code:wght@400;700&amp;display=swap" rel="stylesheet" type="text/css" />
  <link href="styles.css" rel="stylesheet" type="text/css" />
</head><body id="top">
  <script src="script.js"></script>
<h1><a href="index.html">How to merge two lists in Python</a></h1><div><div><div><p>Merging lists in Python combines multiple sequences into a unified collection. Python offers several built-in methods and operators like <code>extend()</code>, <code>+</code>, and list comprehension to efficiently merge lists while maintaining data integrity.</p><p>This guide covers essential merging techniques, optimization strategies, and real-world applications, with code examples created using <a href="https://claude.ai/">Claude</a>, an AI assistant built by Anthropic.</p><h2>Using the <code>+</code> operator</h2><pre><code>list1 = [1, 2, 3]
list2 = [4, 5, 6]
merged_list = list1 + list2
print(merged_list)</code></pre><pre><code>[1, 2, 3, 4, 5, 6]</code></pre><p>The <code>+</code> operator creates a new list by concatenating the elements from both input lists in sequence. This approach maintains the original order of elements while keeping the source lists unchanged‚Äîa crucial feature when you need to preserve your input data.</p><p>While straightforward, the <code>+</code> operator's memory usage scales with the size of both lists since it creates a completely new list in memory. For small to medium-sized lists, this rarely impacts performance. However, when working with very large datasets, methods like <code>extend()</code> often prove more memory-efficient.</p><h2>Basic list merging techniques</h2><p>Beyond the <code>+</code> operator, Python offers three powerful list merging approaches‚Äî<code>extend()</code>, <code>itertools.chain()</code>, and list comprehension‚Äîeach optimized for specific use cases.</p><h3>Using the <code>extend()</code> method</h3><pre><code>list1 = [1, 2, 3]
list2 = [4, 5, 6]
list1.extend(list2)
print(list1)</code></pre><pre><code>[1, 2, 3, 4, 5, 6]</code></pre><p>The <code>extend()</code> method modifies the original list by appending all elements from another list. Unlike the <code>+</code> operator, it doesn't create a new list in memory. Instead, it directly adds elements to the end of the existing list.</p><ul><li>The method efficiently handles large datasets since it requires less memory overhead</li><li>After calling <code>extend()</code>, the original list (<code>list1</code>) permanently changes to include all elements from <code>list2</code></li><li>The second list (<code>list2</code>) remains unchanged throughout the process</li></ul><p>This approach particularly shines when you need to combine lists while minimizing memory usage. However, consider using the <code>+</code> operator if you need to preserve the original list's contents.</p><h3>Using <code>itertools.chain()</code></h3><pre><code>import itertools
list1 = [1, 2, 3]
list2 = [4, 5, 6]
merged_list = list(itertools.chain(list1, list2))
print(merged_list)</code></pre><pre><code>[1, 2, 3, 4, 5, 6]</code></pre><p>The <code>itertools.chain()</code> function creates an iterator that efficiently combines multiple sequences without loading the entire dataset into memory at once. This memory-efficient approach makes it particularly useful when working with large lists.</p><ul><li>The function accepts any number of iterables as arguments, not just two lists</li><li>Converting the iterator to a list using <code>list()</code> creates the final merged sequence</li><li>Both input lists remain unchanged throughout the process</li></ul><p>While <code>itertools.chain()</code> requires an extra import statement, it offers significant performance benefits for memory-intensive operations. The function's ability to work with multiple iterables makes it more versatile than basic list concatenation methods.</p><h3>Using list comprehension</h3><pre><code>list1 = [1, 2, 3]
list2 = [4, 5, 6]
merged_list = [item for sublist in [list1, list2] for item in sublist]
print(merged_list)</code></pre><pre><code>[1, 2, 3, 4, 5, 6]</code></pre><p>List comprehension offers a concise, readable way to merge lists in a single line of code. The syntax <code>[item for sublist in [list1, list2] for item in sublist]</code> creates a new list by iterating through each element of both input lists.</p><ul><li>The outer loop <code>for sublist in [list1, list2]</code> processes each source list</li><li>The inner loop <code>for item in sublist</code> extracts individual elements</li><li>Python combines these elements into the final merged list while maintaining their original order</li></ul><p>This approach particularly shines when you need clean, expressive code that clearly shows your intent. It creates a new list in memory similar to the <code>+</code> operator. Consider using <code>extend()</code> instead for very large lists where memory efficiency matters more than syntax elegance.</p><h2>Advanced list merging techniques</h2><p>Beyond the foundational merging techniques, Python offers specialized tools like the <code>*</code> operator, duplicate handling, and NumPy arrays to handle complex list operations with greater control and performance.</p><h3>Using the unpacking operator <code>*</code></h3><pre><code>list1 = [1, 2, 3]
list2 = [4, 5, 6]
merged_list = [*list1, *list2]
print(merged_list)</code></pre><pre><code>[1, 2, 3, 4, 5, 6]</code></pre><p>The unpacking operator <code>*</code> elegantly expands each list's elements into a new list. When you write <code>[*list1, *list2]</code>, Python unpacks all elements from both lists into the square brackets, creating a merged list.</p><ul><li>The <code>*</code> operator works with any iterable object. You can unpack multiple lists, tuples, or sets in a single line</li><li>This syntax creates a new list in memory. The original lists remain unchanged</li><li>The order of elements follows the sequence you specify in the square brackets</li></ul><p>This modern approach offers cleaner syntax compared to traditional concatenation methods. It's especially useful when you need to merge multiple sequences in a readable way.</p><h3>Merging lists while removing duplicates</h3><pre><code>list1 = [1, 2, 3, 4]
list2 = [3, 4, 5, 6]
merged_list = list(dict.fromkeys(list1 + list2))
print(merged_list)</code></pre><pre><code>[1, 2, 3, 4, 5, 6]</code></pre><p>This technique combines list merging with duplicate removal in a single operation. The <code>dict.fromkeys()</code> method creates a dictionary using list elements as keys, automatically eliminating duplicates since dictionary keys must be unique. Converting the result back to a list preserves the original order while keeping only unique values.</p><ul><li>The <code>+</code> operator first combines both lists: <code>[1, 2, 3, 4, 3, 4, 5, 6]</code></li><li><code>dict.fromkeys()</code> transforms this into a dictionary with unique keys</li><li>The final <code>list()</code> conversion produces <code>[1, 2, 3, 4, 5, 6]</code></li></ul><p>This approach particularly shines when working with datasets that might contain overlapping values. It maintains clean, readable code while efficiently handling duplicate removal in a memory-conscious way.</p><h3>Using NumPy for high-performance merging</h3><pre><code>import numpy as np
array1 = np.array([1, 2, 3])
array2 = np.array([4, 5, 6])
merged_array = np.concatenate((array1, array2))
merged_list = merged_array.tolist()
print(merged_list)</code></pre><pre><code>[1, 2, 3, 4, 5, 6]</code></pre><p>NumPy's <code>concatenate()</code> function offers a high-performance alternative for merging large numerical arrays. The method works directly with NumPy's optimized array data structure, making it significantly faster than traditional Python list operations for data-intensive tasks.</p><ul><li>Convert Python lists to NumPy arrays using <code>np.array()</code></li><li>Merge arrays with <code>np.concatenate()</code> which expects a tuple of arrays as input</li><li>Transform the result back to a Python list using <code>tolist()</code> for compatibility with standard Python operations</li></ul><p>This approach particularly excels when processing large datasets or performing complex mathematical operations. NumPy's underlying C implementation delivers superior performance compared to Python's built-in list methods.</p><h3>Combining movie watchlists with the <code>+</code> operator</h3><p>The <code>+</code> operator elegantly combines two movie watchlists into a unified family collection, making it simple to merge different viewing preferences while preserving everyone's favorite films in their original order.</p><pre><code>parent_watchlist = [&quot;Inception&quot;, &quot;The Matrix&quot;, &quot;Interstellar&quot;]
child_watchlist = [&quot;Frozen&quot;, &quot;Toy Story&quot;, &quot;The Lion King&quot;]
family_watchlist = parent_watchlist + child_watchlist
print(&quot;Family movie night options:&quot;)
for movie in family_watchlist:
    print(f&quot;- {movie}&quot;)</code></pre><p>This code demonstrates list concatenation and iteration to create a movie display system. The <code>+</code> operator combines two separate lists into <code>family_watchlist</code>, preserving the exact order of movies from both collections.</p><ul><li>The <code>print()</code> statement creates a header for the movie list</li><li>The <code>for</code> loop processes each movie title sequentially</li><li>F-strings (<code>f&quot;- {movie}&quot;</code>) format each title with a bullet point prefix</li></ul><p>When executed, this code outputs a neatly formatted list where each movie appears on its own line, preceded by a dash. The approach efficiently handles any number of movies in either input list while maintaining a clean, readable display format.</p><h3>Analyzing sales data after merging with the <code>+</code> operator</h3><p>The <code>+</code> operator enables rapid analysis of combined sales data from multiple stores by merging separate revenue lists into a unified dataset for calculating key metrics like averages and identifying performance trends.</p><pre><code>store1_sales = [1200, 1500, 900]
store2_sales = [1000, 1300, 1100]
all_sales = store1_sales + store2_sales
average_sale = sum(all_sales) / len(all_sales)
highest_sale = max(all_sales)
lowest_sale = min(all_sales)
print(f&quot;Average sale: ${average_sale:.2f}&quot;)
print(f&quot;Highest sale: ${highest_sale}&quot;)
print(f&quot;Lowest sale: ${lowest_sale}&quot;)</code></pre><p>This code demonstrates efficient sales data analysis using Python's built-in list operations. The <code>+</code> operator combines two separate sales lists into <code>all_sales</code>, creating a unified dataset for analysis. Three key calculations follow: <code>sum()</code> divided by <code>len()</code> computes the average sale amount, while <code>max()</code> and <code>min()</code> identify the highest and lowest values respectively.</p><ul><li>F-strings format the output with clear labels and dollar signs</li><li>The <code>:.2f</code> format specifier ensures the average displays exactly two decimal places</li><li>Each metric prints on a new line for easy reading</li></ul><p>This straightforward approach handles numerical analysis without requiring external libraries or complex logic structures.</p><h2>Common errors and challenges</h2><p>Python developers frequently encounter three critical challenges when merging lists: distinguishing between similar methods, preventing data corruption, and resolving type compatibility issues.</p><h3>Fixing confusion between <code>append()</code> and <code>extend()</code></h3><p>Developers often misuse <code>append()</code> when they actually need <code>extend()</code>. While <code>extend()</code> adds individual elements from a second list, <code>append()</code> treats the entire second list as a single element. This distinction creates unexpected nested structures.</p><pre><code>list1 = [1, 2, 3]
list2 = [4, 5, 6]
list1.append(list2)
print(list1)</code></pre><p>The code creates a nested list structure because <code>append()</code> adds <code>list2</code> as a single element, resulting in <code>[1, 2, 3, [4, 5, 6]]</code> instead of a flat merged list. Check out the corrected implementation below.</p><pre><code>list1 = [1, 2, 3]
list2 = [4, 5, 6]
list1.extend(list2)
print(list1)</code></pre><p>The <code>extend()</code> method correctly flattens <code>list2</code> into <code>list1</code>, adding each element individually. This produces the expected <code>[1, 2, 3, 4, 5, 6]</code> instead of a nested structure. Watch for this common pitfall when combining lists‚Äî<code>append()</code> always adds its argument as a single item, even when that item is itself a list.</p><ul><li>Use <code>extend()</code> when you want to merge all elements from one list into another</li><li>Choose <code>append()</code> only when you intentionally need nested lists</li><li>Double-check your method choice when working with list operations to avoid unintended data structures</li></ul><h3>Avoiding unintended list modifications with <code>.extend()</code></h3><p>The <code>extend()</code> method permanently modifies the original list by adding elements from another list. This behavior can cause issues when you need to preserve the original data. The code below demonstrates how <code>extend()</code> alters the source list, making it impossible to revert to its initial state.</p><pre><code>original = [1, 2, 3]
additional = [4, 5, 6]
original.extend(additional)
print(original)
print(&quot;Original data preserved:&quot;, original == [1, 2, 3])</code></pre><p>The <code>extend()</code> method directly modifies <code>original</code>, making it impossible to access the initial values later. This permanent change creates data integrity issues in applications that need to reference or reuse the original list. Let's examine the proper solution in the following code.</p><pre><code>original = [1, 2, 3]
additional = [4, 5, 6]
merged = original + additional
print(merged)
print(&quot;Original data preserved:&quot;, original == [1, 2, 3])</code></pre><p>The <code>+</code> operator creates a new list while preserving the original data. This approach solves the data integrity issues that <code>extend()</code> can cause. The original lists remain unchanged and accessible for future operations.</p><ul><li>Always consider whether you need to preserve the original data before choosing a merging method</li><li>Use <code>+</code> when data preservation matters more than memory efficiency</li><li>Watch for scenarios where multiple functions might need access to the original list values</li></ul><p>This pattern becomes especially important in larger applications where data flows through multiple functions or when implementing features like undo functionality.</p><h3>Handling type errors when merging with <code>+</code></h3><p>The <code>+</code> operator requires matching data types when merging sequences. Python raises a <code>TypeError</code> when you attempt to combine lists with incompatible types like strings or integers. This common issue often surfaces when processing user input or working with mixed data sources.</p><pre><code>numbers = [1, 2, 3]
user_input = &quot;4&quot;  # Simulating user input as string
result = numbers + user_input
print(result)</code></pre><p>The code fails because Python can't directly combine a list with a string using <code>+</code>. The interpreter expects both operands to be lists. The error message <code>TypeError: can only concatenate list (not "str") to list</code> appears. Check out the corrected implementation below.</p><pre><code>numbers = [1, 2, 3]
user_input = &quot;4&quot;  # Simulating user input as string
result = numbers + [int(user_input)]
print(result)</code></pre><p>The solution wraps the string input in square brackets and converts it to an integer using <code>int()</code> before concatenation. This creates a single-element list that Python can properly merge with the existing <code>numbers</code> list using the <code>+</code> operator.</p><ul><li>Watch for type mismatches when merging data from different sources like user inputs, file reads, or API responses</li><li>Always validate and convert data types before attempting list operations</li><li>Consider using list comprehension for bulk type conversions when dealing with multiple elements</li></ul></div></div></div><h2>FAQs</h2><div><div><h3>What is the difference between using the plus operator and the extend() method to combine lists?</h3><div><div><div><p>The <code>+</code> operator creates a new list by copying all elements, while <code>extend()</code> modifies the existing list by adding elements directly. This difference affects both memory usage and performance.</p><ul><li>Using <code>+</code> requires more memory since it creates a new list object in memory</li><li><code>extend()</code> is more efficient for large lists since it avoids copying elements</li><li>Choose <code>extend()</code> when modifying a list in place. Use <code>+</code> when you need to preserve the original list unchanged</li></ul></div></div></div></div></div><div><div><h3>How can I merge lists while removing duplicate elements?</h3><div><div><div><p>To merge lists and remove duplicates, you can use Python's built-in <code>set</code> data structure, which automatically handles duplicate elimination. Converting your lists to sets with the <code>set()</code> function enables you to combine them using the <code>union()</code> operator <code>|</code> or <code>union()</code> method.</p><p>This approach works efficiently because sets store only unique elements and use hash tables internally for fast lookups. Convert the final result back to a list using <code>list()</code> if you need an ordered sequence.</p></div></div></div></div></div><div><div><h3>Does concatenating lists with the plus operator modify the original lists?</h3><div><div><div><p>No, concatenating lists with the <code>+</code> operator doesn't modify the original lists. Instead, it creates a new list containing all elements from both lists in sequence. This behavior aligns with Python's commitment to predictable data handling.</p><p>The original lists remain unchanged because list concatenation follows value semantics rather than reference semantics. This approach helps prevent unexpected side effects in your code while giving you explicit control over list modifications.</p></div></div></div></div></div><div><div><h3>Can I merge lists of different data types together in Python?</h3><div><div><div><p>Python lets you merge lists containing different data types using the <code>+</code> operator or <code>extend()</code> method. This flexibility stems from Python's dynamic typing system, which doesn't enforce type consistency within lists.</p><p>You can combine integers, strings, and even nested data structures in a single list. However, consider these practical implications:</p><ul><li>Mixed-type lists can make operations like sorting more complex</li><li>Type checking becomes more important when processing combined lists</li><li>Code readability might suffer with overly diverse list contents</li></ul></div></div></div></div></div><div><div><h3>Which list merging method is most memory efficient for large lists?</h3><div><div><div><p>The <code>extend()</code> method offers the most memory-efficient approach for merging large lists in Python. Unlike the <code>+</code> operator which creates a new list object, <code>extend()</code> modifies the existing list in place by adding each element from the source list. This eliminates the need for temporary memory allocation during the merge process.</p><p>For example, when merging two lists of 1 million elements each, <code>extend()</code> requires only the memory for the final combined list. The <code>+</code> operator would temporarily need memory for three lists‚Äîboth original lists plus the new combined one.</p></div></div></div></div></div><h2>üè†</h2></body></html>