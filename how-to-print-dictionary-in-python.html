<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title>How to print a dictionary in Python</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@700&amp;family=Literata:wght@400;700&amp;family=Fira+Code:wght@400;700&amp;display=swap" rel="stylesheet" type="text/css" />
  <link href="styles.css" rel="stylesheet" type="text/css" />
</head><body id="top">
  <script src="script.js"></script>
<h1><a href="index.html">How to print a dictionary in Python</a></h1><div><div><div><p>Dictionaries in Python store key-value pairs that let you organize and access data efficiently. Understanding how to print dictionaries properly helps you debug code, analyze data structures, and create readable program output.</p><p>This guide covers essential dictionary printing techniques, with practical tips and real-world examples. All code samples were developed with <a href="https://claude.ai/">Claude</a>, an AI assistant built by Anthropic.</p><h2>Basic printing with <code>print()</code></h2><pre><code>my_dict = {&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30, &#x27;city&#x27;: &#x27;New York&#x27;}
print(my_dict)</code></pre><pre><code>{&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30, &#x27;city&#x27;: &#x27;New York&#x27;}</code></pre><p>The <code>print()</code> function displays dictionaries in a straightforward key-value format, making it ideal for quick debugging and data inspection. When you pass a dictionary directly to <code>print()</code>, Python automatically converts it to a string representation that preserves the dictionary's structure.</p><p>This basic printing method offers several advantages for developers:</p><ul><li>Maintains the exact structure of nested data</li><li>Shows the data types of values through quotation marks and formatting</li><li>Requires no additional imports or configuration</li></ul><p>While simple, this approach works best for small dictionaries or initial debugging. The output becomes harder to read with larger or more complex dictionary structures.</p><h2>Basic dictionary printing methods</h2><p>Python offers several methods beyond basic <code>print()</code> to display dictionaries more elegantly and extract specific information you need for your programs.</p><h3>Iterating through keys with a <code>for</code> loop</h3><pre><code>person = {&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30, &#x27;city&#x27;: &#x27;New York&#x27;}
for key in person:
    print(f&quot;{key}: {person[key]}&quot;)</code></pre><pre><code>name: John
age: 30
city: New York</code></pre><p>The <code>for</code> loop provides a clean way to display each key-value pair on its own line. Python automatically iterates through dictionary keys, letting you access corresponding values using square bracket notation <code>person[key]</code>.</p><ul><li>Each iteration prints one key-value pair using an f-string, creating a vertical list format that's easier to read than the default dictionary output</li><li>This method gives you more control over formatting compared to basic <code>print()</code></li><li>You can easily modify the output format by changing the f-string template</li></ul><p>The vertical format makes the dictionary's contents more scannable, especially when working with larger data structures or when you need to present the information to other developers.</p><h3>Using the <code>items()</code> method for key-value pairs</h3><pre><code>person = {&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30, &#x27;city&#x27;: &#x27;New York&#x27;}
for key, value in person.items():
    print(key, &quot;-&gt;&quot;, value)</code></pre><pre><code>name -&gt; John
age -&gt; 30
city -&gt; New York</code></pre><p>The <code>items()</code> method provides a more elegant way to access both keys and values simultaneously. It returns key-value pairs that you can directly unpack in a <code>for</code> loop, eliminating the need for bracket notation.</p><ul><li>The syntax <code>for key, value in person.items()</code> automatically unpacks each pair into separate variables</li><li>This approach makes the code more readable and reduces the chance of errors when accessing dictionary values</li><li>You can name the loop variables anything meaningful—not just "key" and "value"</li></ul><p>The arrow operator <code>-></code> in the print statement creates a clear visual separation between keys and values. This formatting choice makes the output particularly useful when reviewing dictionary contents during development or debugging sessions.</p><h3>String formatting with dictionary unpacking</h3><pre><code>person = {&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30, &#x27;city&#x27;: &#x27;New York&#x27;}
print(&quot;Person: {name}, {age} years old, from {city}&quot;.format(**person))</code></pre><pre><code>Person: John, 30 years old, from New York</code></pre><p>Dictionary unpacking with the double asterisk operator (<code>**</code>) automatically maps dictionary keys to their corresponding placeholders in a format string. This technique creates more readable and maintainable code when you need to insert multiple dictionary values into a text template.</p><ul><li>The <code>format()</code> method looks for placeholders that match dictionary keys</li><li>The <code>**person</code> syntax expands the dictionary into individual keyword arguments</li><li>Python raises a <code>KeyError</code> if a placeholder doesn't match any dictionary key</li></ul><p>This approach particularly shines when working with form letters, report templates, or any situation where you need to combine dictionary data into a predefined text structure. The resulting code is cleaner than concatenation or multiple format arguments.</p><h2>Advanced dictionary printing techniques</h2><p>Building on the basic printing methods, Python offers powerful modules and formatting techniques that transform complex dictionary data into highly readable, well-structured output for both developers and end users.</p><h3>Pretty printing with the <code>pprint</code> module</h3><pre><code>from pprint import pprint
nested_dict = {&#x27;person&#x27;: {&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30}, 
               &#x27;location&#x27;: {&#x27;city&#x27;: &#x27;New York&#x27;, &#x27;country&#x27;: &#x27;USA&#x27;}}
pprint(nested_dict, width=40)</code></pre><pre><code>{&#x27;location&#x27;: {&#x27;city&#x27;: &#x27;New York&#x27;,
              &#x27;country&#x27;: &#x27;USA&#x27;},
 &#x27;person&#x27;: {&#x27;age&#x27;: 30, &#x27;name&#x27;: &#x27;John&#x27;}}</code></pre><p>The <code>pprint</code> module transforms complex nested dictionaries into a more readable format. It automatically handles indentation and line breaks, making deeply nested structures easier to understand at a glance.</p><ul><li>The <code>width</code> parameter controls the maximum line length before wrapping occurs</li><li>Each nested level receives consistent indentation for visual hierarchy</li><li>Dictionary items appear alphabetically by default, helping you locate specific keys quickly</li></ul><p>This formatting proves especially valuable when debugging or logging nested data structures where standard <code>print()</code> would produce a dense, hard-to-parse single line. The clear visual structure helps you spot patterns and relationships in your data more effectively.</p><h3>JSON formatting for readable output</h3><pre><code>import json
person = {&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30, &#x27;city&#x27;: &#x27;New York&#x27;}
formatted_dict = json.dumps(person, indent=4)
print(formatted_dict)</code></pre><pre><code>{
    &quot;name&quot;: &quot;John&quot;,
    &quot;age&quot;: 30,
    &quot;city&quot;: &quot;New York&quot;
}</code></pre><p>The <code>json.dumps()</code> function converts Python dictionaries into JSON-formatted strings, creating output that's both human-readable and compatible with other systems. The <code>indent</code> parameter adds consistent spacing that visually organizes the data hierarchy.</p><ul><li>Setting <code>indent=4</code> creates four spaces of indentation for each nested level</li><li>The function automatically wraps each key-value pair on a new line</li><li>JSON formatting converts Python's single quotes to double quotes, following the JSON standard</li></ul><p>This approach works particularly well when you need to share dictionary data with other developers or systems. The structured output makes it easy to spot relationships between data elements while maintaining a format that's ready for data exchange.</p><h3>Custom alignment and formatting for tabular display</h3><pre><code>inventory = {&#x27;apple&#x27;: 10, &#x27;banana&#x27;: 15, &#x27;orange&#x27;: 8, &#x27;grape&#x27;: 25}
print(&quot;Inventory:&quot;)
for item, quantity in inventory.items():
    print(f&quot;{item.ljust(10)} : {quantity:3d} units&quot;)</code></pre><pre><code>Inventory:
apple      :  10 units
banana     :  15 units
orange     :   8 units
grape      :  25 units</code></pre><p>String formatting methods create clean, aligned dictionary output that's perfect for displaying tabular data. The <code>ljust()</code> method pads strings with spaces on the right side, while <code>:3d</code> reserves three spaces for integer values.</p><ul><li>The <code>ljust(10)</code> ensures each item name occupies exactly 10 characters, creating a uniform left column</li><li>The <code>:3d</code> format specifier aligns numbers in the right column, making quantities easy to scan</li><li>The colon separator adds visual structure between the columns</li></ul><p>This formatting technique transforms raw dictionary data into a clear, professional-looking table. It's especially useful when presenting inventory lists, configuration settings, or any data that benefits from columnar alignment.</p><h3>Displaying user settings with <code>status</code> indicators</h3><p>The <code>status</code> indicator pattern transforms boolean settings into visual checkmarks and crosses, creating an intuitive display that helps users quickly scan their current configuration state.</p><pre><code>user_settings = {
    &#x27;notifications&#x27;: True,
    &#x27;dark_mode&#x27;: False,
    &#x27;auto_save&#x27;: True,
    &#x27;sharing&#x27;: False
}

for setting, enabled in user_settings.items():
    status = &quot;✓&quot; if enabled else &quot;✗&quot;
    print(f&quot;{setting.replace(&#x27;_&#x27;, &#x27; &#x27;).title()}: {status}&quot;)</code></pre><p>This code creates a user-friendly display of application settings stored in a dictionary. The dictionary <code>user_settings</code> maps setting names to boolean values that indicate whether each feature is enabled or disabled.</p><p>The <code>for</code> loop iterates through the dictionary using <code>items()</code> to access both keys and values. For each setting, the code performs two key transformations:</p><ul><li>Converts <code>True/False</code> values into checkmark (✓) or cross (✗) symbols using a conditional expression</li><li>Formats setting names by replacing underscores with spaces and capitalizing words using <code>replace()</code> and <code>title()</code></li></ul><p>The f-string combines these elements into a clean, readable output that makes it easy to scan the current state of all settings at a glance.</p><h3>Creating a mini dashboard from website <code>analytics</code> data</h3><p>This example demonstrates how to transform raw website analytics data into a clean, scannable dashboard using Python's string formatting capabilities and dictionary operations.</p><pre><code>analytics = {
    &#x27;visitors&#x27;: 12500,
    &#x27;page_views&#x27;: 48700,
    &#x27;bounce_rate&#x27;: 0.35,
    &#x27;avg_time&#x27;: 127,
    &#x27;conversion&#x27;: 0.063
}

print(&quot;WEBSITE ANALYTICS DASHBOARD&quot;)
print(f&quot;Visitors: {analytics[&#x27;visitors&#x27;]:,}&quot;)
print(f&quot;Page Views: {analytics[&#x27;page_views&#x27;]:,}&quot;)
print(f&quot;Bounce Rate: {analytics[&#x27;bounce_rate&#x27;]:.1%}&quot;)
print(f&quot;Avg. Time on Site: {analytics[&#x27;avg_time&#x27;] // 60}m {analytics[&#x27;avg_time&#x27;] % 60}s&quot;)
print(f&quot;Conversion Rate: {analytics[&#x27;conversion&#x27;]:.2%}&quot;)</code></pre><p>This code creates a polished analytics dashboard by combining Python's dictionary structure with advanced string formatting. The <code>analytics</code> dictionary stores key metrics as numerical values. Each <code>print()</code> statement uses f-strings with specialized formatting codes to display the data clearly:</p><ul><li>The <code>:,</code> format code adds thousands separators to large numbers</li><li>The <code>:.1%</code> and <code>:.2%</code> codes convert decimals to percentages with specific decimal places</li><li>The <code>//</code> and <code>%</code> operators convert seconds into minutes and remaining seconds</li></ul><p>The output transforms raw numbers into a readable format that makes sense for each metric type. This approach lets you present complex data in a way that's immediately meaningful to users.</p><h2>Common errors and challenges</h2><p>Python dictionaries can trigger several common errors that frustrate developers when printing or accessing data—understanding these challenges helps you write more reliable code.</p><h3>Handling <code>KeyError</code> when accessing non-existent keys</h3><p>A <code>KeyError</code> occurs when your code tries to access a dictionary key that doesn't exist. This common Python exception can crash your program if not handled properly. The following code demonstrates what happens when we attempt to access a missing <code>phone</code> key in a dictionary.</p><pre><code>user_data = {&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;email&#x27;: &#x27;alice@example.com&#x27;}
print(f&quot;User: {user_data[&#x27;name&#x27;]}, Phone: {user_data[&#x27;phone&#x27;]}&quot;)</code></pre><p>The code fails because it directly references the non-existent <code>'phone'</code> key without first checking if it exists. This triggers Python's built-in error handling. The following code demonstrates a safer approach to accessing dictionary values.</p><pre><code>user_data = {&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;email&#x27;: &#x27;alice@example.com&#x27;}
if &#x27;phone&#x27; in user_data:
    print(f&quot;User: {user_data[&#x27;name&#x27;]}, Phone: {user_data[&#x27;phone&#x27;]}&quot;)
else:
    print(f&quot;User: {user_data[&#x27;name&#x27;]}, Phone: Not provided&quot;)</code></pre><p>The code demonstrates a defensive programming approach to handle missing dictionary keys. Instead of directly accessing values, it first checks for key existence using the <code>in</code> operator. This prevents the <code>KeyError</code> exception that would crash your program.</p><ul><li>Always verify key existence before accessing dictionary values in production code</li><li>Use the <code>get()</code> method as an alternative to provide default values</li><li>Watch for this error when working with user input or external data sources where dictionary structure isn't guaranteed</li></ul><p>This pattern proves especially valuable when processing data from APIs, user forms, or configuration files where missing keys are common. The conditional check creates more resilient code that gracefully handles incomplete data.</p><h3>Using the <code>get()</code> method to handle missing keys</h3><p>The <code>get()</code> method provides a safer alternative to direct key access when working with dictionaries. Instead of crashing with a <code>KeyError</code>, it returns a default value when a key doesn't exist. The following code demonstrates what happens when we try to access a missing key directly.</p><pre><code>preferences = {&#x27;theme&#x27;: &#x27;dark&#x27;, &#x27;font_size&#x27;: 14}
print(f&quot;Language: {preferences[&#x27;language&#x27;]}, Theme: {preferences[&#x27;theme&#x27;]}&quot;)</code></pre><p>The code fails because it directly accesses the <code>language</code> key without first checking its existence. This triggers a <code>KeyError</code> exception that halts program execution. Let's examine a more robust approach using the <code>get()</code> method.</p><pre><code>preferences = {&#x27;theme&#x27;: &#x27;dark&#x27;, &#x27;font_size&#x27;: 14}
print(f&quot;Language: {preferences.get(&#x27;language&#x27;, &#x27;default&#x27;)}, Theme: {preferences[&#x27;theme&#x27;]}&quot;)</code></pre><p>The <code>get()</code> method provides a safer way to access dictionary values by returning a default value when a key doesn't exist. In the example, <code>preferences.get('language', 'default')</code> returns 'default' if the language key is missing instead of raising an error.</p><ul><li>Watch for this pattern when working with data from external sources like APIs or user input</li><li>Use <code>get()</code> whenever you're unsure if a key exists in your dictionary</li><li>The second parameter of <code>get()</code> lets you specify any fallback value. This creates more resilient code that won't break unexpectedly</li></ul><h3>Dealing with <code>TypeError</code> when printing dictionaries with mixed types</h3><p>A <code>TypeError</code> occurs when you perform operations on incompatible data types in a dictionary. This common issue surfaces when mixing strings, integers, and <code>None</code> values without proper type conversion. The following code demonstrates how attempting arithmetic with mixed types leads to errors.</p><pre><code>metrics = {&#x27;views&#x27;: &#x27;1500&#x27;, &#x27;likes&#x27;: &#x27;300&#x27;, &#x27;shares&#x27;: None}
total = metrics[&#x27;views&#x27;] + metrics[&#x27;likes&#x27;] + metrics[&#x27;shares&#x27;]
print(f&quot;Total engagement: {total}&quot;)</code></pre><p>The code fails because it attempts to concatenate string values with <code>None</code> using the <code>+</code> operator. Python can't automatically combine these different data types. The following example shows the proper way to handle mixed data types in dictionaries.</p><pre><code>metrics = {&#x27;views&#x27;: &#x27;1500&#x27;, &#x27;likes&#x27;: &#x27;300&#x27;, &#x27;shares&#x27;: None}
views = int(metrics[&#x27;views&#x27;]) if metrics[&#x27;views&#x27;] else 0
likes = int(metrics[&#x27;likes&#x27;]) if metrics[&#x27;likes&#x27;] else 0
shares = int(metrics[&#x27;shares&#x27;]) if metrics[&#x27;shares&#x27;] else 0
total = views + likes + shares
print(f&quot;Total engagement: {total}&quot;)</code></pre><p>The code demonstrates proper type handling by converting string values to integers before performing arithmetic. It uses conditional expressions to check for <code>None</code> values and provides default values of 0 when needed. This pattern prevents <code>TypeError</code> exceptions that commonly occur when working with data from external sources like APIs or CSV files.</p><ul><li>Watch for this error when processing user input or imported data where type consistency isn't guaranteed</li><li>Always validate and convert data types before performing operations</li><li>Consider using type hints and data validation libraries for larger applications</li></ul><p>The solution creates a robust foundation for handling mixed data types in dictionaries. This approach proves especially valuable when building data processing pipelines or analytics systems where data quality varies.</p></div></div></div><h2>FAQs</h2><div><div><h3>What is the simplest way to display a dictionary&#x27;s contents?</h3><div><div><div><p>The <code>print()</code> function offers the most straightforward way to display a dictionary's contents. When you pass a dictionary directly to <code>print()</code>, Python automatically converts it to a readable string format, showing each key-value pair within curly braces.</p><p>This built-in functionality makes debugging and data inspection effortless. For more specific formatting needs, you can use dictionary methods like <code>items()</code> to access and display individual elements.</p></div></div></div></div></div><div><div><h3>How can I print dictionary keys and values on separate lines?</h3><div><div><div><p>Python dictionaries store data as key-value pairs. To print keys and values separately, you can use the built-in <code>keys()</code> and <code>values()</code> methods. These methods return view objects that you can iterate through with a <code>for</code> loop.</p><ul><li>Print keys: <code>for key in dict.keys(): print(key)</code></li><li>Print values: <code>for value in dict.values(): print(value)</code></li></ul><p>The view objects provide a dynamic window into the dictionary's contents. When the dictionary changes, the views automatically reflect those changes without requiring additional memory.</p></div></div></div></div></div><div><div><h3>What&#x27;s the difference between using print() directly versus pprint() for dictionaries?</h3><div><div><div><p>The <code>print()</code> function displays dictionaries in a single line, which becomes hard to read with nested data structures. <code>pprint()</code> (pretty print) formats dictionaries with consistent indentation and line breaks, making complex data more scannable.</p><ul><li>While <code>print()</code> works well for simple dictionaries, <code>pprint()</code> automatically handles nested structures by creating visual hierarchies</li><li><code>pprint()</code> sorts dictionary keys by default—this helps when comparing data or debugging</li><li>The trade-off comes down to readability versus compactness. Use <code>print()</code> for quick checks of small dictionaries. Choose <code>pprint()</code> when working with complex nested data that needs clear visual organization</li></ul></div></div></div></div></div><div><div><h3>Can I print only the keys or only the values from a dictionary?</h3><div><div><div><p>Yes, Python dictionaries provide built-in methods to access keys and values separately. Use <code>dict.keys()</code> to get all keys or <code>dict.values()</code> to get all values. These methods return special view objects that automatically update when the dictionary changes.</p><ul><li>Keys are unique identifiers that help you organize and retrieve data efficiently</li><li>Values can be any data type and may contain duplicates</li><li>View objects save memory by not creating copies of the data</li></ul><p>You can convert these views to lists using <code>list()</code> if you need a static snapshot of the data.</p></div></div></div></div></div><div><div><h3>How do I format dictionary output to make it more readable?</h3><div><div><div><p>Python's built-in <code>pprint</code> module formats dictionaries with automatic line breaks and indentation, making complex nested structures easier to read. The <code>pprint.pprint()</code> function displays each key-value pair on a new line.</p><p>For even better readability, use <code>json.dumps()</code> with the <code>indent</code> parameter. This creates JSON-style formatting that works well for both simple and nested dictionaries. The indentation level controls how much whitespace appears between nested elements.</p></div></div></div></div></div><h2>🏠</h2></body></html>