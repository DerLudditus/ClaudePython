<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><title>How to create a dictionary in Python</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@700&amp;family=Literata:wght@400;700&amp;family=Fira+Code:wght@400;700&amp;display=swap" rel="stylesheet" type="text/css" />
  <link href="styles.css" rel="stylesheet" type="text/css" />
</head><body id="top">
  <script src="script.js"></script>
<h1><a href="index.html">How to create a dictionary in Python</a></h1><div><div><div><p>Python dictionaries store key-value pairs that let you organize and access data efficiently. These versatile data structures use curly braces <code>{}</code> and colons to map unique keys to their corresponding values, enabling fast lookups and modifications.</p><p>This guide covers essential dictionary techniques, practical examples, and troubleshooting tips—with code samples created using <a href="https://claude.ai/">Claude</a>, an AI assistant built by Anthropic.</p><h2>Creating a dictionary with curly braces</h2><pre><code>person = {&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;}
print(person)</code></pre><pre><code>{&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 30, &#x27;city&#x27;: &#x27;New York&#x27;}</code></pre><p>The dictionary in this example maps three distinct keys (<code>"name"</code>, <code>"age"</code>, and <code>"city"</code>) to their respective values, creating a structured way to store related data about a person. Each key serves as a unique identifier that makes the corresponding value easily accessible.</p><p>Python dictionaries offer several advantages over using separate variables or lists for related data:</p><ul><li>They keep related information organized in a single container</li><li>They provide semantic meaning through descriptive key names</li><li>They enable faster lookups compared to searching through lists</li><li>They maintain a clear relationship between data points</li></ul><h2>Different initialization methods</h2><p>Beyond using curly braces, Python provides three powerful methods to initialize dictionaries: the <code>dict()</code> constructor, sequence-based creation, and dictionary comprehensions.</p><h3>Using the <code>dict()</code> constructor</h3><pre><code>person = dict(name=&quot;Alice&quot;, age=30, city=&quot;New York&quot;)
print(person)</code></pre><pre><code>{&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 30, &#x27;city&#x27;: &#x27;New York&#x27;}</code></pre><p>The <code>dict()</code> constructor provides a cleaner syntax for creating dictionaries when your keys are valid Python identifiers. Instead of using colons and quotes, you can pass key-value pairs as keyword arguments—similar to how you'd call a function.</p><ul><li>Keys become unquoted parameter names (<code>name=</code>, <code>age=</code>, <code>city=</code>)</li><li>Values can be any valid Python expression</li><li>The constructor automatically converts parameter names to strings</li></ul><p>This approach reduces visual clutter and potential syntax errors. However, it only works when dictionary keys follow Python's variable naming rules. For keys containing spaces or special characters, stick to the curly brace syntax.</p><h3>Creating dictionaries from sequences</h3><pre><code>items = [(&quot;name&quot;, &quot;Alice&quot;), (&quot;age&quot;, 30), (&quot;city&quot;, &quot;New York&quot;)]
person = dict(items)
print(person)</code></pre><pre><code>{&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 30, &#x27;city&#x27;: &#x27;New York&#x27;}</code></pre><p>The <code>dict()</code> constructor transforms sequences of key-value pairs into dictionaries. When you pass a list of tuples to <code>dict()</code>, each tuple's first element becomes a key and its second element becomes the corresponding value.</p><ul><li>Each tuple in the sequence must contain exactly two elements</li><li>The first element (key) must be immutable and hashable</li><li>The second element (value) can be any valid Python object</li></ul><p>This method excels when your data already exists in a paired format. It's particularly useful when processing data from external sources or converting other data structures into dictionaries. The sequence-based approach offers more flexibility than keyword arguments since keys don't need to follow Python's identifier rules.</p><h3>Using dictionary comprehensions</h3><pre><code>names = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;]
scores = [95, 87, 92]
grade_dict = {name: score for name, score in zip(names, scores)}
print(grade_dict)</code></pre><pre><code>{&#x27;Alice&#x27;: 95, &#x27;Bob&#x27;: 87, &#x27;Charlie&#x27;: 92}</code></pre><p>Dictionary comprehensions provide a concise way to create dictionaries by transforming and filtering data. The syntax mirrors list comprehensions but uses curly braces and requires both a key and value expression.</p><p>In this example, the <code>zip()</code> function pairs each student name with their corresponding score. The comprehension <code>{name: score for name, score in zip(names, scores)}</code> then creates dictionary entries from these pairs.</p><ul><li>The expression before <code>for</code> defines the key-value structure (<code>name: score</code>)</li><li>The part after <code>for</code> specifies how to iterate through the data</li><li>Python automatically matches each name to its score based on position</li></ul><p>This approach streamlines dictionary creation compared to manual key assignment or using the <code>dict()</code> constructor. It works especially well when transforming parallel lists into key-value relationships.</p><h2>Advanced dictionary techniques</h2><p>Beyond these foundational techniques, Python dictionaries offer specialized methods like <code>fromkeys()</code>, nested structures, and <code>defaultdict</code> to handle complex data relationships more elegantly.</p><h3>Creating dictionaries with <code>fromkeys()</code> method</h3><pre><code>keys = [&quot;name&quot;, &quot;age&quot;, &quot;city&quot;]
default_value = &quot;Unknown&quot;
person = dict.fromkeys(keys, default_value)
print(person)</code></pre><pre><code>{&#x27;name&#x27;: &#x27;Unknown&#x27;, &#x27;age&#x27;: &#x27;Unknown&#x27;, &#x27;city&#x27;: &#x27;Unknown&#x27;}</code></pre><p>The <code>fromkeys()</code> method creates a dictionary by assigning the same value to multiple keys. This built-in function takes two arguments: an iterable containing the desired keys and a default value that each key will reference.</p><ul><li>The first argument (<code>keys</code>) defines what keys the dictionary will contain</li><li>The second argument (<code>default_value</code>) sets the initial value for all keys</li><li>Python automatically maps each key to the specified default value</li></ul><p>This approach proves particularly useful when initializing dictionaries with placeholder values or creating templates for data structures. The method saves time compared to manually assigning the same value to multiple keys.</p><h3>Creating nested dictionaries</h3><pre><code>employees = {
    &quot;Alice&quot;: {&quot;department&quot;: &quot;Engineering&quot;, &quot;salary&quot;: 85000},
    &quot;Bob&quot;: {&quot;department&quot;: &quot;Marketing&quot;, &quot;salary&quot;: 75000}
}
print(employees[&quot;Alice&quot;][&quot;department&quot;])</code></pre><pre><code>Engineering</code></pre><p>Nested dictionaries embed one dictionary inside another, creating hierarchical data structures. The example shows an employee database where each person's name links to another dictionary containing their details.</p><ul><li>Each employee (like <code>"Alice"</code>) acts as a key that maps to their own dictionary of attributes</li><li>Access nested values by chaining square brackets: <code>employees["Alice"]["department"]</code> retrieves <code>"Engineering"</code></li><li>This structure efficiently organizes complex, related data that belongs together</li></ul><p>Nested dictionaries excel at representing real-world relationships where objects have multiple properties. They're particularly useful for storing structured data like employee records, product catalogs, or game character attributes.</p><h3>Using <code>defaultdict</code> for automatic initialization</h3><pre><code>from collections import defaultdict
grades = defaultdict(list)
grades[&quot;Alice&quot;].append(95)
grades[&quot;Alice&quot;].append(92)
print(dict(grades))</code></pre><pre><code>{&#x27;Alice&#x27;: [95, 92]}</code></pre><p><code>defaultdict</code> automatically creates a default value when you access a non-existent key. In this example, <code>defaultdict(list)</code> initializes an empty list whenever you reference a new key. This eliminates the need to check if a key exists before appending values.</p><ul><li>Regular dictionaries raise a <code>KeyError</code> when accessing missing keys</li><li><code>defaultdict</code> handles missing keys gracefully by creating the specified default value</li><li>The argument passed to <code>defaultdict</code> (<code>list</code> in this case) determines the type of default value</li></ul><p>This functionality proves especially useful when collecting multiple values per key. The code demonstrates this by appending two grades for Alice without explicitly creating an empty list first.</p><h3>Counting word frequencies using <code>.get()</code> method</h3><p>The <code>.get()</code> method enables efficient word frequency counting by safely retrieving dictionary values with a default fallback, eliminating the need for explicit key existence checks.</p><pre><code>text = &quot;the quick brown fox jumps over the lazy dog&quot;
word_count = {}
for word in text.lower().split():
    word_count[word] = word_count.get(word, 0) + 1
print(word_count)</code></pre><p>This code creates a dictionary that tracks how many times each word appears in a text string. The <code>text.lower().split()</code> converts the string to lowercase and breaks it into individual words. For each word, the code uses <code>.get()</code> to either retrieve its current count or return 0 if the word isn't in the dictionary yet.</p><ul><li>The dictionary <code>word_count</code> stores words as keys and their frequencies as values</li><li>Each time a word appears, its count increases by 1</li><li>The <code>.get()</code> method provides a clean way to handle both new and existing words in a single line</li></ul><p>This pattern serves as a foundation for text analysis tasks like finding common words or identifying patterns in large text datasets.</p><h3>Building a memoization cache for the <code>fibonacci()</code> function</h3><p>Dictionaries serve as efficient caching tools to dramatically speed up recursive functions by storing previously calculated results, as demonstrated in this optimized <code>fibonacci()</code> implementation that uses a dictionary parameter <code>cache</code> to remember computed Fibonacci numbers.</p><pre><code>def fibonacci_with_cache(n, cache={}):
    if n in cache:
        return cache[n]
    if n &lt;= 1:
        return n
    cache[n] = fibonacci_with_cache(n-1) + fibonacci_with_cache(n-2)
    return cache[n]

print(fibonacci_with_cache(10))
print(fibonacci_with_cache(20))  # Much faster with caching</code></pre><p>This implementation of <code>fibonacci_with_cache</code> uses a dictionary to store previously calculated Fibonacci numbers. The function first checks if the requested number exists in the cache. If it does, it returns that value immediately instead of recalculating it.</p><p>When calculating new values, the function stores each result in the cache before returning it. This smart caching strategy prevents redundant calculations of the same Fibonacci numbers during recursive calls.</p><ul><li>The default empty dictionary parameter <code>cache={}</code> persists between function calls</li><li>The base case <code>if n &lt;= 1: return n</code> handles inputs 0 and 1</li><li>Each new calculation adds to the cache using <code>cache[n]</code> as the storage key</li></ul><p>This approach transforms an exponential-time algorithm into a linear-time solution by trading memory for speed.</p><h2>Common errors and challenges</h2><p>Python dictionaries can trigger subtle errors when handling missing keys, mutable defaults, or iteration—understanding these challenges helps you write more reliable code.</p><h3>Handling missing keys with the <code>.get()</code> method</h3><p>Accessing a nonexistent dictionary key with square bracket notation triggers a <code>KeyError</code>. This common pitfall can crash your program when retrieving values that might not exist. The code below demonstrates this error when trying to access a missing <code>email</code> key.</p><pre><code>user_data = {&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30}
email = user_data[&quot;email&quot;]  # KeyError: &#x27;email&#x27;
print(f&quot;User email: {email}&quot;)</code></pre><p>The code attempts to directly access a dictionary key that doesn't exist in <code>user_data</code>. When Python can't find the <code>email</code> key, it immediately halts execution instead of gracefully handling the missing value. Let's examine a safer approach in the code below.</p><pre><code>user_data = {&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30}
email = user_data.get(&quot;email&quot;, &quot;No email provided&quot;)
print(f&quot;User email: {email}&quot;)</code></pre><p>The <code>.get()</code> method provides a safer way to access dictionary values by accepting a default fallback value. When you request a key that doesn't exist, <code>.get()</code> returns the specified default instead of raising an error. This approach prevents your program from crashing when dealing with uncertain data structures.</p><ul><li>Always use <code>.get()</code> when accessing keys that might not exist</li><li>Choose meaningful default values that make sense for your data type</li><li>Consider using <code>.get()</code> in data processing pipelines or when handling user input</li></ul><p>Watch for this pattern especially when working with API responses, user-provided data, or any situation where the dictionary structure isn't guaranteed.</p><h3>Avoiding mutable default parameter pitfall with dictionaries</h3><p>Python's mutable default parameters can create unexpected behavior in dictionary operations. When you define a function with a dictionary as a default parameter, Python creates the dictionary only once during function definition instead of each time you call the function. The code below demonstrates this subtle trap.</p><pre><code>def add_score(name, score, leaderboard={}):
    leaderboard[name] = score
    return leaderboard

print(add_score(&quot;Alice&quot;, 95))
print(add_score(&quot;Bob&quot;, 87))  # Still contains Alice&#x27;s score!</code></pre><p>The <code>leaderboard</code> dictionary persists between function calls because Python reuses the same default object. This means all function calls share and modify the same dictionary. The code below demonstrates the proper way to handle this situation.</p><pre><code>def add_score(name, score, leaderboard=None):
    if leaderboard is None:
        leaderboard = {}
    leaderboard[name] = score
    return leaderboard

print(add_score(&quot;Alice&quot;, 95))
print(add_score(&quot;Bob&quot;, 87))  # Fresh dictionary each time</code></pre><p>Using <code>None</code> as the default parameter and creating a new dictionary inside the function solves the mutable default issue. This pattern ensures each function call starts with a fresh dictionary instead of reusing the same object. The <code>if leaderboard is None</code> check creates a new dictionary only when needed.</p><ul><li>Watch for this issue when using any mutable default parameter (lists, dictionaries, sets)</li><li>The problem often surfaces in caching functions or data collectors that need independent state</li><li>Remember that Python evaluates default arguments once during function definition</li></ul><p>This pattern appears frequently in real-world applications that process user data or maintain separate records for different operations. Always initialize mutable defaults to <code>None</code> and create the actual object inside the function body.</p><h3>Safely modifying dictionaries during iteration</h3><p>Modifying a dictionary while iterating through it triggers a <code>RuntimeError</code>. Python raises this error to prevent unpredictable behavior when you add or remove items during a loop. The code below demonstrates what happens when you try to delete dictionary entries while looping through them.</p><pre><code>data = {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4}
for key in data:
    if data[key] % 2 == 0:  # Remove even values
        del data[key]  # RuntimeError: dictionary changed during iteration</code></pre><p>The dictionary's size changes when <code>del</code> removes items. Python's iterator can't track these modifications while moving through the collection. The next code sample demonstrates a reliable approach to filter dictionary entries.</p><pre><code>data = {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4}
keys_to_remove = [k for k, v in data.items() if v % 2 == 0]
for key in keys_to_remove:
    del data[key]
print(data)  # {&#x27;a&#x27;: 1, &#x27;c&#x27;: 3}</code></pre><p>This solution creates a separate list of keys to remove before modifying the dictionary. The list comprehension <code>[k for k, v in data.items() if v % 2 == 0]</code> identifies even-valued entries first. Then a separate loop safely removes those keys from the dictionary.</p><ul><li>Watch for this error when filtering dictionaries based on their values</li><li>The pattern applies when removing entries that match specific conditions</li><li>Consider using dictionary comprehension to create a new filtered dictionary instead of modifying the original</li></ul><p>This two-step approach prevents the <code>RuntimeError</code> by separating the iteration from the modification. Python can safely traverse the dictionary structure when changes happen after the initial loop completes.</p></div></div></div><h2>FAQs</h2><div><div><h3>How do you create an empty dictionary in Python?</h3><div><div><div><p>Python offers three ways to create an empty dictionary. The most common method uses curly braces: <code>{}</code>. You can also use the <code>dict()</code> constructor function. Both approaches create the same result—an empty key-value storage container ready for data.</p><p>Dictionaries serve as efficient lookup tables, letting you store and retrieve values using unique keys. While curly braces provide a cleaner syntax, the constructor method offers additional flexibility when working with sequences or iterables.</p></div></div></div></div></div><div><div><h3>What&#x27;s the difference between using curly braces and the dict() function?</h3><div><div><div><p>Both <code>dict()</code> and curly braces create dictionaries in Python, but they serve different purposes. <code>dict()</code> excels at converting other data types into dictionaries and accepts keyword arguments for direct dictionary creation. Curly braces offer a more concise, readable syntax for creating dictionaries with string keys or when you need to include expressions.</p><ul><li>Use <code>dict()</code> when working with sequences of key-value pairs or when converting compatible data structures</li><li>Choose curly braces for direct, literal dictionary creation—especially with string keys or nested structures</li></ul></div></div></div></div></div><div><div><h3>Can you add elements to a dictionary after creating it?</h3><div><div><div><p>Yes, Python dictionaries are mutable objects that support dynamic modification after creation. You can add new key-value pairs using either the <code>dict[key] = value</code> syntax or the <code>update()</code> method. This flexibility stems from Python's hash table implementation, which efficiently manages memory allocation and retrieval.</p><ul><li>Single item addition: <code>my_dict['new_key'] = value</code> directly inserts one pair</li><li>Multiple additions: <code>update()</code> merges multiple key-value pairs from another dictionary or iterable</li></ul><p>This design enables dictionaries to grow organically as your program's needs evolve. The hash table structure maintains fast O(1) average-case performance for insertions.</p></div></div></div></div></div><div><div><h3>How do you create a dictionary with initial key-value pairs?</h3><div><div><div><p>Python dictionaries store key-value pairs using curly braces <code>{}</code>. You can create them in two ways: directly assign values using <code>dict = {'key': 'value'}</code>, or use the <code>dict()</code> constructor with keyword arguments like <code>dict(key='value')</code>.</p><p>The curly brace method offers more flexibility since keys can be any immutable type. The constructor approach works well when your keys are valid Python identifiers—perfect for configuration settings or default parameters.</p></div></div></div></div></div><div><div><h3>What happens if you try to create a dictionary with duplicate keys?</h3><div><div><div><p>When you create a dictionary with duplicate keys, Python keeps only the last value assigned to that key. This behavior stems from how dictionaries work internally: they must maintain unique keys to enable fast lookups. For example, if you define <code>{"a": 1, "a": 2}</code>, the final dictionary will contain <code>{"a": 2}</code>.</p><p>This design choice prioritizes data integrity and performance. Since dictionaries serve as fast lookup tables, having duplicate keys would create ambiguity about which value to return when accessing a key.</p></div></div></div></div></div></body></html>