<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"/><title>How to write an algorithm in Python</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@700&amp;family=Literata:wght@400;700&amp;family=Fira+Code:wght@400;700&amp;display=swap" rel="stylesheet" type="text/css" />
  <link href="styles.css" rel="stylesheet" type="text/css" />
</head><body id="top">
  <script src="script.js"></script>
<h1><a href="index.html">How to write an algorithm in Python</a></h1><div><div><div><p>Python algorithms transform complex problems into efficient, step-by-step solutions. Whether you're sorting data, searching through lists, or optimizing performance, understanding algorithm fundamentals helps you write better code and solve problems systematically.</p><p>This guide covers essential techniques, practical tips, and real-world applications for writing robust algorithms, with code examples created using <a href="https://claude.ai/">Claude</a>, an AI assistant built by Anthropic.</p><h2>Creating a simple algorithm with a function</h2><pre><code>def calculate_average(numbers):
    total = sum(numbers)
    return total / len(numbers)

result = calculate_average([10, 20, 30, 40, 50])
print(f&quot;The average is: {result}&quot;)</code></pre><pre><code>The average is: 30.0</code></pre><p>The <code>calculate_average</code> function demonstrates a fundamental algorithmic pattern: breaking down a complex operation into smaller, reusable steps. This approach transforms raw data into meaningful insights through systematic processing.</p><p>The algorithm follows key principles that make it both efficient and maintainable:</p><ul><li>Single responsibility: The function handles one specific task</li><li>Input validation: It expects a list of numbers as input</li><li>Clear output: It returns a calculated average without side effects</li></ul><p>While this example may seem straightforward, it establishes essential practices for building more sophisticated algorithms. The function's structure creates a reusable template that developers can adapt for handling various numerical computations.</p><h2>Basic algorithm design patterns</h2><p>Building on these foundational patterns, Python's control structures and modular design enable you to create robust, production-ready algorithms that handle edge cases gracefully.</p><h3>Using control structures in algorithms</h3><pre><code>def find_maximum(numbers):
    if not numbers:
        return None
    max_value = numbers[0]
    for num in numbers:
        if num &gt; max_value:
            max_value = num
    return max_value

print(find_maximum([5, 12, 9, 42, 17]))</code></pre><pre><code>42</code></pre><p>The <code>find_maximum</code> function demonstrates essential control structures that form the backbone of algorithmic thinking. It combines conditional logic and iteration to systematically process data and handle edge cases.</p><ul><li>The initial <code>if not numbers</code> check prevents errors by returning <code>None</code> for empty lists</li><li>Setting <code>max_value</code> to the first element creates a baseline for comparison</li><li>The <code>for</code> loop systematically compares each number to find the highest value</li><li>A simple <code>if</code> statement updates <code>max_value</code> when a larger number is found</li></ul><p>This pattern showcases how combining basic control structures creates robust algorithms that handle varying inputs reliably. The function maintains efficiency by making just one pass through the data while tracking the maximum value.</p><h3>Adding input validation to your <code>calculate_discount()</code> algorithm</h3><pre><code>def calculate_discount(price, discount_percent):
    if not isinstance(price, (int, float)) or price &lt; 0:
        raise ValueError(&quot;Price must be a positive number&quot;)
    if not 0 &lt;= discount_percent &lt;= 100:
        raise ValueError(&quot;Discount must be between 0 and 100&quot;)
    
    return price * (1 - discount_percent / 100)

print(calculate_discount(100, 20))</code></pre><pre><code>80.0</code></pre><p>Input validation transforms this discount calculator into a robust, production-ready function. The code systematically checks for invalid inputs before processing any calculations.</p><ul><li>The first validation uses <code>isinstance()</code> to ensure <code>price</code> is a number and verifies it's not negative</li><li>The second check confirms <code>discount_percent</code> falls between 0 and 100</li><li>Both checks raise clear error messages that help developers quickly identify and fix issues</li></ul><p>This defensive programming approach prevents subtle bugs that could arise from invalid inputs. The function returns the discounted price only after confirming all parameters meet the required criteria.</p><h3>Creating modular algorithms with helper functions</h3><pre><code>def is_prime(n):
    if n &lt;= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def get_primes_below(limit):
    return [num for num in range(2, limit) if is_prime(num)]

print(get_primes_below(20))</code></pre><pre><code>[2, 3, 5, 7, 11, 13, 17, 19]</code></pre><p>This code demonstrates how breaking algorithms into focused helper functions improves readability and reusability. The <code>is_prime()</code> function handles a single task: determining if a number is prime. The <code>get_primes_below()</code> function then uses this helper to generate a list of prime numbers.</p><ul><li>The <code>is_prime()</code> function efficiently checks divisibility up to the square root of the input number</li><li>Using <code>is_prime()</code> as a helper makes the code more maintainable and easier to test</li><li>The list comprehension in <code>get_primes_below()</code> shows how modular functions enable cleaner, more expressive code</li></ul><p>This modular approach creates building blocks you can combine to solve more complex problems. Each function has a clear, single purpose that makes debugging and modifications straightforward.</p><h2>Advanced algorithm techniques</h2><p>Building on these modular foundations, Python offers powerful techniques to optimize algorithm performance through binary search, decorators, and recursive memoization patterns.</p><h3>Implementing <code>binary_search()</code> with optimized time complexity</h3><pre><code>def binary_search(sorted_list, target):
    left, right = 0, len(sorted_list) - 1
    
    while left &lt;= right:
        mid = (left + right) // 2
        if sorted_list[mid] == target:
            return mid
        elif sorted_list[mid] &lt; target:
            left = mid + 1
        else:
            right = mid - 1
            
    return -1  # Not found

print(binary_search([1, 3, 5, 7, 9, 11], 5))</code></pre><pre><code>2</code></pre><p>Binary search dramatically speeds up finding items in sorted lists by systematically eliminating half the remaining search space with each comparison. The algorithm maintains two pointers, <code>left</code> and <code>right</code>, to track the current search boundaries.</p><ul><li>The <code>mid</code> calculation finds the center point between <code>left</code> and <code>right</code> pointers</li><li>If the middle value matches the target, we return its index</li><li>When the middle value is too small, we search the right half by moving <code>left</code></li><li>When it's too large, we search the left half by moving <code>right</code></li></ul><p>This divide-and-conquer approach achieves O(log n) time complexity. The algorithm returns -1 if the target isn't found after exhausting all possible positions.</p><h3>Using decorators to enhance algorithm functionality</h3><pre><code>import time

def timing_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f&quot;Function {func.__name__} took {end_time - start_time:.6f} seconds&quot;)
        return result
    return wrapper

@timing_decorator
def sort_algorithm(arr):
    return sorted(arr)

sort_algorithm([5, 2, 9, 1, 5, 6])</code></pre><pre><code>Function sort_algorithm took 0.000058 seconds
[1, 2, 5, 5, 6, 9]</code></pre><p>Decorators transform how functions behave without changing their internal code. The <code>timing_decorator</code> wraps around functions to measure their execution time. When applied to <code>sort_algorithm</code>, it automatically tracks how long the sorting process takes.</p><ul><li>The <code>wrapper</code> function captures the start and end times using <code>time.time()</code></li><li>It executes the original function between these time measurements</li><li>The decorator prints the elapsed time and returns the function's result</li></ul><p>This pattern enables performance monitoring across multiple functions by simply adding the <code>@timing_decorator</code> annotation. You can apply the same decorator to any function where you need to track execution time. The approach demonstrates how Python's decorator syntax elegantly extends function behavior without cluttering the main logic.</p><h3>Writing efficient recursive algorithms with memoization</h3><pre><code>def fibonacci(n, memo={}):
    if n in memo:
        return memo[n]
    if n &lt;= 1:
        return n
    memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)
    return memo[n]

for i in range(10):
    print(fibonacci(i), end=&quot; &quot;)</code></pre><pre><code>0 1 1 2 3 5 8 13 21 34</code></pre><p>The <code>fibonacci</code> function uses memoization to dramatically speed up recursive calculations. This technique stores previously computed results in the <code>memo</code> dictionary, preventing redundant calculations of the same Fibonacci numbers.</p><ul><li>The function first checks if we've already calculated the result for <code>n</code> using <code>if n in memo</code></li><li>Base cases handle inputs of 0 and 1 directly</li><li>For larger numbers, the function stores each new calculation in <code>memo</code> before returning it</li></ul><p>Without memoization, calculating the 100th Fibonacci number would require billions of recursive calls. With memoization, the function needs only 99 calculations. This transforms an exponential time complexity into a linear one, making the algorithm significantly more efficient.</p><h3>Using algorithms for text analysis with <code>count_word_frequency()</code></h3><p>The <code>count_word_frequency()</code> function transforms raw text into a structured dictionary that maps each word to its number of occurrences, enabling efficient analysis of word patterns and language usage.</p><pre><code>def count_word_frequency(text):
    words = text.lower().split()
    frequency = {}
    for word in words:
        frequency[word] = frequency.get(word, 0) + 1
    return frequency

sample_text = &quot;The quick brown fox jumps over the lazy dog&quot;
print(count_word_frequency(sample_text))</code></pre><p>The <code>count_word_frequency</code> function efficiently tracks how often each word appears in a text. It first converts the input text to lowercase and splits it into individual words. The function then creates an empty dictionary to store word counts.</p><p>For each word in the text, the function uses the dictionary's <code>get()</code> method to either retrieve the current count or return 0 if the word is new. It adds 1 to this count and stores the updated value. This elegant approach handles both new and existing words in a single line.</p><ul><li>Lowercase conversion ensures "The" and "the" count as the same word</li><li>The <code>split()</code> method automatically handles multiple spaces between words</li><li>Dictionary lookups provide fast O(1) access to word counts</li></ul><h3>Implementing a <code>filter_and_analyze()</code> function for data processing</h3><p>The <code>filter_and_analyze()</code> function combines data filtering and statistical analysis to transform raw numerical data into meaningful insights through a clean dictionary interface.</p><pre><code>def filter_and_analyze(data, threshold):
    if not isinstance(threshold, (int, float)):
        raise ValueError(&quot;Threshold must be a number&quot;)
    
    filtered_data = [x for x in data if x &gt; threshold]
    
    if not filtered_data:
        return {&quot;count&quot;: 0, &quot;average&quot;: None, &quot;max&quot;: None}
    
    return {
        &quot;count&quot;: len(filtered_data),
        &quot;average&quot;: sum(filtered_data) / len(filtered_data),
        &quot;max&quot;: max(filtered_data)
    }

sensor_readings = [23.1, 19.8, 31.4, 18.9, 27.5, 22.2]
print(filter_and_analyze(sensor_readings, 25))</code></pre><p>The <code>filter_and_analyze</code> function processes numerical data and returns statistical insights in a dictionary format. It first validates that the threshold parameter is actually a number. Using a list comprehension, it creates <code>filtered_data</code> containing only values above the specified threshold.</p><ul><li>If no values pass the threshold filter, it returns a dictionary with zero count and <code>None</code> values</li><li>For valid filtered data, it calculates three metrics: count of values, their average, and the maximum value</li></ul><p>When run with <code>sensor_readings</code> and a threshold of 25, the function returns statistics only for readings above 25—making it useful for scenarios like monitoring sensor data that exceeds specific thresholds.</p><h2>Common errors and challenges</h2><p>Python algorithms can fail in subtle ways when handling edge cases like empty lists, infinite recursion, and mutable default arguments. Understanding these pitfalls helps you write more robust code.</p><h3>Handling empty lists in the <code>calculate_average()</code> function</h3><p>The <code>calculate_average()</code> function fails when processing empty lists. This common edge case triggers a <code>ZeroDivisionError</code> because the function attempts to divide by zero. A robust implementation must handle empty inputs gracefully.</p><pre><code>def calculate_average(numbers):
    total = sum(numbers)
    return total / len(numbers)
    
print(calculate_average([]))</code></pre><p>When <code>calculate_average()</code> receives an empty list, Python attempts to divide the sum (0) by the length (0). This triggers a <code>ZeroDivisionError</code>. The code below demonstrates a more resilient approach to this challenge.</p><pre><code>def calculate_average(numbers):
    if not numbers:
        return 0
    total = sum(numbers)
    return total / len(numbers)
    
print(calculate_average([]))</code></pre><p>The improved <code>calculate_average()</code> function adds a crucial validation check using <code>if not numbers</code> to handle empty lists. This prevents the <code>ZeroDivisionError</code> by returning 0 when the input list contains no elements.</p><ul><li>Always validate inputs before performing calculations that could trigger division by zero</li><li>Consider whether returning 0 or raising an exception makes more sense for your use case</li><li>Watch for similar edge cases when working with other mathematical operations like finding averages, percentages, or ratios</li></ul><p>This pattern applies broadly to functions that compute statistics or perform calculations on collections. Empty or null inputs often require special handling to prevent runtime errors.</p><h3>Preventing infinite recursion in the <code>factorial()</code> function</h3><p>The <code>factorial()</code> function calculates the product of all integers from 1 to n. Without proper base conditions, recursive functions can call themselves indefinitely. This leads to stack overflow errors that crash your program. The code below demonstrates this common pitfall.</p><pre><code>def factorial(n):
    return n * factorial(n-1)

print(factorial(5))</code></pre><p>The <code>factorial()</code> function keeps calling itself with <code>n-1</code> without a stopping condition. Each recursive call adds to the program's memory stack until it runs out of space. The corrected implementation below adds the necessary base case.</p><pre><code>def factorial(n):
    if n &lt;= 1:
        return 1
    return n * factorial(n-1)

print(factorial(5))</code></pre><p>The improved <code>factorial()</code> function adds a crucial base case that stops the recursion when <code>n</code> reaches 1 or less. This prevents infinite recursion by providing a clear exit condition. The function now safely calculates factorials by multiplying <code>n</code> by the factorial of <code>n-1</code> until it hits the base case.</p><ul><li>Watch for missing base cases in any recursive function</li><li>Test edge cases like 0 and negative numbers</li><li>Consider using iteration instead of recursion for large inputs to avoid stack overflow</li></ul><p>This pattern applies to all recursive algorithms. Always ensure your recursive functions have well-defined stopping conditions before they start calling themselves.</p><h3>Avoiding bugs with mutable default arguments in the <code>append_to_list()</code> function</h3><p>Python's mutable default arguments create a subtle trap that catches many developers. The <code>append_to_list()</code> function demonstrates how using an empty list as a default parameter leads to unexpected behavior when the function runs multiple times.</p><pre><code>def append_to_list(item, my_list=[]):
    my_list.append(item)
    return my_list

print(append_to_list(1))
print(append_to_list(2))</code></pre><p>Python creates the default <code>my_list</code> parameter only once when defining the function. Each subsequent call modifies the same list object instead of creating a fresh empty list. The code below demonstrates the proper implementation.</p><pre><code>def append_to_list(item, my_list=None):
    if my_list is None:
        my_list = []
    my_list.append(item)
    return my_list

print(append_to_list(1))
print(append_to_list(2))</code></pre><p>The improved <code>append_to_list()</code> function uses <code>None</code> as the default argument instead of an empty list. This prevents the common pitfall where Python reuses the same mutable list across multiple function calls. Setting <code>my_list=None</code> and creating a new list inside the function ensures each call starts fresh.</p><ul><li>Watch for mutable defaults in function parameters including lists, dictionaries, and sets</li><li>Use <code>None</code> as the default argument when working with mutable data structures</li><li>Create new mutable objects inside the function body instead of the parameter list</li></ul><p>This pattern applies whenever you need optional mutable arguments in your functions. The fix ensures predictable behavior by isolating each function call's data.</p></div></div></div><h2>FAQs</h2><div><div><h3>How do you start writing a basic algorithm in Python?</h3><div><div><div><p>Start by defining your algorithm's purpose and expected inputs/outputs. Break down the problem into smaller logical steps that you can translate into Python code. Use descriptive variable names like <code>total_sales</code> instead of <code>x</code>.</p><p>Structure your code with basic Python elements: variables store data, <code>if/else</code> statements control flow, and loops handle repetition. Add comments to explain complex logic. Test your algorithm with sample inputs to verify it works correctly.</p></div></div></div></div></div><div><div><h3>What is the difference between using &#x27;for&#x27; loops and &#x27;while&#x27; loops in algorithms?</h3><div><div><div><p>The key difference lies in their control flow. A <code>for</code> loop works best when you know exactly how many iterations you need—like processing items in a list or counting from 1 to 10. A <code>while</code> loop shines when the number of iterations depends on a condition that changes during execution.</p><p>Think of a <code>for</code> loop as following a recipe with clear steps. A <code>while</code> loop resembles playing a game until you win or lose. The <code>while</code> loop continues until its condition becomes false, making it ideal for scenarios like user input validation or processing data streams.</p></div></div></div></div></div><div><div><h3>How can you test if your Python algorithm is working correctly?</h3><div><div><div><p>Testing Python algorithms requires a systematic approach. Start by validating your code with small, predictable inputs where you can manually verify the expected outputs. Create test cases that check edge conditions like empty lists, negative numbers, and boundary values.</p><ul><li>Use the <code>assert</code> statement to automatically verify results</li><li>Compare algorithm output against known correct solutions</li><li>Test with both valid and invalid inputs to ensure proper error handling</li></ul><p>Break down complex algorithms into smaller functions. This makes testing more manageable and helps isolate issues when they occur. Document your test cases to make future maintenance easier.</p></div></div></div></div></div><div><div><h3>What are some common built-in functions like len() and max() that help with algorithms?</h3><div><div><div><p>Python's built-in functions streamline common algorithmic operations. <code>len()</code> counts elements in sequences like lists and strings, while <code>max()</code> and <code>min()</code> find extreme values. These functions handle the heavy lifting of iteration and comparison behind the scenes.</p><ul><li><code>sorted()</code> efficiently orders collections using optimized algorithms</li><li><code>sum()</code> adds numeric sequences without manual loops</li><li><code>enumerate()</code> pairs indices with values during iteration</li></ul><p>These tools reduce code complexity and improve readability by abstracting implementation details into single function calls.</p></div></div></div></div></div><div><div><h3>When should you break down a complex algorithm into smaller functions?</h3><div><div><div><p>Break down complex algorithms when they exceed a single, clear responsibility. This improves code readability and makes testing easier. Functions like <code>processUserData</code> should handle one task instead of authentication, validation, and database updates simultaneously.</p><ul><li>Split functions when they reach 20-30 lines. Long functions often indicate multiple responsibilities</li><li>Create separate functions for operations you might need to reuse or modify independently</li><li>Break out complex calculations or business logic that other developers need to understand quickly</li></ul></div></div></div></div></div><h2>🏠</h2></body></html>